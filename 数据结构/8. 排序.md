
# 一、排序

## 排序方法分类
$$\begin{cases}\text { 按数据存储介质: } & \text { 内部排序和外部排序 } \\ \text { 按比较器个数: } & \text { 串行排序和并行排序 } \\ \text { 按主要操作: } & \text { 比较排序和基数排序 } \\ \text { 按辅助空间: } & \text { 原地排序和非原地排序 } \\ \text { 按稳定性: } & \text { 稳定排序和非稳定排序 } \\ \text { 按自然性: } & \text { 自然排序和非自然排序 }\end{cases}$$

**内部排序**：数据量不大、数据在内存，无需内外存交换数据
**外部排序**：数据量较大、数据在外存（外部排序时，需要将数据分批调入内存来排序，中间结果还要及时存入外）

**串行排序**：单处理机（同一时刻比较一对元素）
**并行排序**：多处理机（同一时刻比较多对元素）

**比较排序**：比较方法 —— *插入排序、交换排序、选择排序、归并排序*
**基数排序**：不比较大小，仅仅根据元素本身的取值确定其有序位置


**原地排序**：辅助空间为 O (1)
**非原地排序**：辅助空间大小超过 O (1)


**稳定排序**：能够使任何数值相等的元素，排序以后相对次序不变 —— *直接插入法*
**非稳定性排序**：不是稳定排序的方法 —— *简单排序*


**自然排序**：输入数据越有序，排序的速度越快
**非自然排序**：输入数据越有序，排序的速度越慢


##  数据结构

顺序表存储
```c
#define MAXSIZE 20
typede int KeyType; //关键字数据类型

//每个记录（数据元素）的结构
Typedef struct{
	KeyType key; //关键字
	InfoType otherinfo; //其他数据项
}RedType;

//顺序表的结构
Typedef struct {
	RedType r[MAXSIZE+1]; //r[0]一般用作哨兵或缓冲区
	int length;
}SqList; 

```



# 二、插入排序

**基本思想**：将待排序的对象，插入到已经排好序的一组对象的适当位置上，直至对象全部插入为止。

**边插边排序**，保证子序列中随时都是排好序的。

例如：待插入元素为 $a[i]$, 则 $a[:i]$ 是有序的，而 $a[i:n]$ 是无序的


定位插入排序的位置通常有三种方法：
- 直接插入排序（顺序查找法定位插入位置）
- 二分插入排序（二分法定位插入位置）
- 希尔排序（缩小增量多遍插入排序）

### 1. 直接插入排序

**顺序查找法**查找插入位置（从后往前找插入位置）——（可加入哨兵，减少每次的迭代的比较）



**方法：**
- 复制待插元素（通过哨兵记录）
- 记录后移，查找插入位置 
- 插入到正确位置

比较 + 移动

**评价：**
- 最好的情况 —— 顺序有序
	- n-1 次比较，0 次移动
- 最坏的情况 —— 逆序有序
- 在顺序有序的、待排序个数较少时比较有利
- 时间复杂度：O ($n^2$)、 空间复杂度 O (1)
-  稳定的排序方法



**提高：**
- 减少比较次数
- 减少元素移动次数



### 2. 二分插入排序

**折半查找法**查找插入位置

- 复制待插元素
- 查找插入位置
- 记录后移动，插入到正确位置


**性能：**

- **比较次数**与待排序对象序列的初始排列无关，与直接插入排序相比减少比较次数
- 而**移动次数**与直接插入排序相同
- 平均性能要优于直接插入排序
- 时间复杂度：O ($n^2$)、 空间复杂度 O (1)
- 稳定排序


### 3. 希尔排序

比较一次移动一大步

**方法：**
- 将整个待排记录序列分割成**若干子序列**（设置间隔），分别进行直接插入排序，
- 待整个序列中的记录**基本有序**时，在对全体记录进行一次直接插入排序

**特点：**
- 缩小增量（设置不同增量序列（递减），最后为 1 ）、增量序列应该是互质的
- 多遍插入排序
- 一次移动，移动位置较大，跳跃式的接近排序后的最终位置
- 最后一次只需要少量移动

![600](sort1.png)


**评价：**
- 算法效率与增量序列的取值有关 
- 时间复杂度 $\mathrm{O}\left(n^{1.25}\right) \sim \mathrm{O}\left(1.6 n^{1.25}\right)$ 一经验公式
- 空间复杂度 O (1)
- 是一种不稳定的排序算法
- 如何选择最佳 d 序列，目前尚未解决，但最后一个增量值必须为1
- 不适合在链式存储上实现（查找消耗时间）


# 三、 交换排序

两两比较，如果发生逆序则交换，直到所有记录都排好序为止。
常见的交换排序方法：
- 冒泡排序
- 快速排序

### 冒泡排序

每趟不断将记录两两比较，并按“前小后大”规则交换；一趟排序确定一个元素位置。

n 个记录，比较 n-1 躺。

可以通过增加一个 flag 作为一趟是否有交换的标记，若无交换，则已经排序好。


评价：
- 最好情况（正序 O(n）、最坏情况（逆序）
- 时间复杂度 O ($n^2$)
- 空间复杂度 O (1) ，交换时需要增加一个辅助空间

### 快速排序

改进的交换排序

**基本思想**：
- 任取一个元素（第一个）为中心
- 所有比它小的元素一律前放，比它大的元素一律后放，形成**左右两个子表**  （双指针）
- 对各子表重新选择中心元素并依此规则调整（递归）
- 直到每个子表的元素只剩一个


**评价：**
- 从两头向中间交替逼近
- 快速排序是**非原地排序**（使用了递归，递归需要栈的支持，而栈的长度取决于递归调用的深度，即使不用递归，也需要用用户栈）
- 空间复杂度：平均情况下，需要 O (logn) 的栈空间，最坏情况下，栈空间可达 O (n)
- 快速排序是一个**不稳定**的排序方法
- 快速排序不适于对原本有序或基本有序的记录序列（正序、逆序都不适合）
- 输入数据次序越乱，所选划分元素值的随机性越好，排序速度越快，快速排序是**非自然排序**。

# 四、选择排序

### 简单选择排序

在待排序的数据中选出最大（小）的元素放在其最终的位置

评价：
- 记录正序移动次数最少为0次
- 比较次数，无论待排序列处于什么状态，选择排序所需进行的“比较”次数都相同。
- 简单排序**不是稳定排序**。
- 空间复杂度：O (1) ，交换临时空间

### 堆排序

若 n 个元素的序列 $\left\{a_1 a_2 \ldots a_n\right\}$ 满足
$\left\{\begin{array}{l}a_i \leq a_{2 i} \\ a_i \leq a_{2 i+1}\end{array} \quad\right.$ 或 $\left\{\begin{array}{l}a_i \geq a_{2 i} \\ a_i \geq a_{2 i+1}\end{array}\right.$ 
则分别称该序列 $\left\{a_1 a_2 \ldots a_n\right\}$ 为**小根堆** 和**大根堆**



堆的实质就是满足如下性质的**完全二叉树**；二叉树中任一非叶子结点**均小于（大于）** 它的孩子结点。

> 完全二叉树标号时，从上到下，从左到右

**排序方法：**
- 输出堆顶的最小值（最大值-大根堆）后
- 使得剩余 n-1 个元素的序列重建成一个堆，则得到 n 个元素的次小值（次大值），
- 如此反复，便能得到一个有序序列， 这个过程称为堆排序

**问题解决：**
- 如何由一个无序序列建成一个堆
- 输出堆顶元素后，剩余元素为一个新的堆

**堆的调整：**
- 输出堆顶元素后，从堆中**最后一个元素**替代
- 然后将根结点值与左、右子树的根结点值进行比较，并与其中小者（大者）进行**交换**；
- 重复上述操作，直至叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程为**筛选**。


**堆的建立：**

基于堆的调整，从一个无序序列建堆的过程就是一个反复筛选的过程

- **单结点**的二叉树是堆
- 在完全二叉树中所有以**叶子结点**为根（左右子树为空）的子树是堆，所以从非叶子结点开始调整
- 因此我们只需要从最后一个非叶子结点开始向前调整，只需要依次将序号为n/2，n/2-1, ... 1的结点为根的子树均调整为堆即可。

堆的实质是线性表，可以顺序存储一个堆
```c
for(i=n/2;i>=1;i--）
	HeapAdjust(R,i,n)
```


**堆排序：**

对一个无序序列建堆，然后输出根；重复该过程就可以由一个无序序列输出有序序列

堆排序利用完全完全二叉树中父结点与孩子结点之间的内在关系来排序。


**评价：**
- 初始堆化：所需时间不超过 O (n)
- 排序阶段：
	- 一次重新堆化所需时间不超过 O (logn)
	- n-1 次循环所需时间不超过 O (nlogn)
- 时间复杂度：O (nlogn)
- 无论最好或最坏、正序或逆序，时间复杂度稳定，堆排序的时间主要消耗在建立初始堆和调整建新堆时进行的反复筛选上。
- 空间复杂度：O (1)   —临时交换空间
- 不稳定排序
- 适用于待排数据比较多的情况

# 五、归并排序

将两个或两个以上的有序序列归并为一个有序序列

在内部排序时，通常采用的是 2-路归并排序

![500](sort3.png)

**关键问题：**
- 如何将两个有序序列合成一个序列（）


**评价：**
- 整个归并排序仅需要（log2n；向上取整），
- 时间效率：O (nlogn) ——  所有元素都要合并一次
- 空间复杂度为 O (n)  需要一个与原始序列同样大小的辅助序列
- 稳定排序



# 六、基数排序

分配 + 收集

非比较排序

也叫桶排序或箱排序：设置若干个箱子，将关键字为 k 的记录放入第 k 个箱子，然后在按序号将非空的连接。

例如：按个位进行分配，分配好后依次收集，收集后在按百位进行分配，然后在收集。

评价：
- 时间效率：O（k*（n+m））
	- k：关键字个数（决定我们需要分配多少躺；例如一个三位数， 需要三趟）
	- m：关键字取值范围为 m 个值
	- n：为待排序元素
- 空间效率：O (n+m)
- 稳定排序


# 总结

![[sort4.png]]

## 时间性能

 *1. 按平均的时间性能来分，有三类排序方法:  

时间复杂度为 **O(nlogn)** 的方法有:  
- 快速排序、堆排序和归并排序，其中以快速排序为最好；  

时间复杂度为 **O($n^2$）**  的有:  
- 直接揷入排序、冒泡排序和简单选择排序，其中以真接揷人为最好,特别是对那些对关键字近似有序的记录序列尤为如此;  

时间复杂度为 **O(n)** 的排序方法只有: 基数排序 （适用性较低）

*2. 当待排记录序列按关键字顺序有序时*

直接揷入排序和冒泡排序能达到 O (n) 的时间复杂度; 而对于快速排序而言，这是最不好的情况，此时的时间性能退化为 O ($n^2$），因此是应该尽量避免的情况。  

3.简单选择排序、堆排序和归并排序的时间性能不随记录序列中关键字的 布而改变。

## 空间性能

指的是排序过程中所需的**辅助空间**大小  
1. 所有的简单排序方法(包括：直接揷入、冒泡和简单选择)和堆排序的空 间复杂度为O(1)
2. 快速排序为O(logn)，为栈所需的辅助空间  
3. 归并排序所需辅助空间最多，其空间复杂度为O(n)
4. 链式基数排序需附设队列首尾指针，则空间复杂度为O(rd)


## 稳定性能

- 稳定的排序方法指的是，对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和经过排序之后，没有改变。  
- 当对多关键䄶的记录序列进行LSD方法排序时，必须采用稳定的排序方法。  
- 对于不稳定的排序方法，只要能举出一个实例说明即可。  
- 快速排序和堆排序是不稳定的排序方法



## 关于排序方法的时间度的下限

- 本章讨论的各种排序方法，除基数排序外，其它方法都是基于 "比较关键字" 进行排序的排序方法，可以证明，这类排序法可能达到的最快的时间复杂度为 O (nlogn)  。 
	(基数排序不是基于 "比较关键字" 的排序方法,所以它不受这个限制)。  
- 可以用一棵**判定树**来描述这类基于 "比较关键字" 进行排序的排序方法。



