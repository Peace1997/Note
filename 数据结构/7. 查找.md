
# 一、 概述

**查找**：给定某个值，在查找表中确定一个其关键字等于给定值的数据元素（记录）。
> 查找成功：给出整个记录的信息，或指示该记录在查找表中位置


通过查找表来进行查找

**查找表**：是由同一类型的数据元素构成的集合。

**关键字**：用来标识一个数据元素（记录）的某个数据项的值
- 主关键字：唯一标识
- 次关键字


查找目的：查询、检索、插入、删除


**分类**：
- 静态查找表：查询、检索
- 动态查找表：插入、删除

**评价**：

**平均查找长度**（ASL）：关键字的平均比较次数

ASL(Average Search Length)
$$
A S L=\sum_{i=1}^{n} {p_{i}} c_i
$$
(关键字比较次数的期望值)
$\mathrm{n}$ : 记录的个数
$p_i$ : 查找第 $i$ 个记录的概率 (通常认为 $p_i=1 / n$ )
$\mathrm{c_i}$ : 找到第 $\mathrm{i}$ 个记录所需的比较次数

# 二、 线性表的查找

## 顺序查找（线性查找）

顺序表、线性链表表示的静态查找表
表内元素之间**无序**

### 数据结构
```c

// 数据元素类型（关键字）
typedef struct{
	KeyType key; //关键字域
	...         //其他域
}

//顺序表定义
typedef struct{
	ElemType *R; //表基址
	int length; //表长
}SSTable; //Seqential Search Table
SSTable ST;//定义顺序表ST

```

**改进**：
增加监视哨，把待查关键字key存入表头，（从后往前查找），可以免去查找过程中每一步的越界判断。

### 评价
**性能分析**：

查找次数与 key 位置有关
时间复杂度：O（n）
ASL = （n+1）/2

空间复杂度：O(1) ——  辅助空间-哨兵


**提升方法**
- 按查找概率高低存储
- 按查找概率动态调整记录顺序

**特点**
- 算法简单、逻辑次序无要求
- ASL 长、效率低

## 折半查找（二分或对分查找）

**每次将待查记录所在区间缩小一半**

mid = （low + high）/2
> low 、 high 表示区间下标

key < R[mid].key 则： high = mid-1
key >R[mid]. key 则： low = mid+1
key == R[mid]. key 则： 找到

high < low, 结束


**实现：**
- 递归
- 非递归

### 评价 —— 判定树

![](search1.png)
平均查找长度：ASL= log2 (n+1) -1
时间复杂度：O(logn)

**特点**：
- 效率比顺序查找高
- 只适用于有序表，且限于顺序存储结构



## 分块查找

1.将表分成几块，且表或者有序，或者**分块有序**（若i<j，则第j块中所有记录的关键字均大于第i块中的最大关键字）
2.建立索引表（每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序）


通常：**块间有序，块内无序**

![[search2.png]]

### 性能分析

log2n $\leq$ ASL = log2 (n/s +1) + s/2 $\leq$ n+1/2

s：每块内部的记录数，n/s：即块的数目

**特点：**
- 插入删除比较容易，无需进行大量移动
- 需要额外增加一个索引表的存储空间并对初始索引表进行排序运算
- 适用：线性表既要快速查找又经常动态变化


![[search3.png]]


# 三、 树表查找

解决：插入删除比较频繁

实现：动态查找表 —— 几种特殊的树

表结构在查找过程中动态生成


## 1. 二叉排序树

又称二叉搜索树，二叉查找树

二叉排序树或是空树，或是满足如下性质的
(1)若其**左子树**非空，则左子树上**所有**结点的值**均小于**根结点的值；
(2) 若其**右子㳔**非空，则右子树上**所有**结点的值**均大于等于**根结点的值；
(3)其左右子树本身又各是一棵二叉排序树

**中序遍历**二叉排序树为**递增**有序序列

### 数据结构
```c
typedef struct{
	KeyType key; //关键字项
	InfoType otherinfo; //其他数据域
}ElemType;

typedef struct BSTNode{
	ElemType data;
	struct BSTNode *lchild,*rchild;
} BSTNode,*BSTree

BSTree T; //定义二叉排序树

```


### 评价

比较关键字次数 = 此结点所在层次数
> 最大比较次数为树的深度

与**树的高度**有关

最好与折半查找中的判定树相同 O (log2 n）
最坏（单支树）与顺序查找相同 O(n)

### 插入、生成、删除

#### 插入和生成
一个无序序列可通过构造二叉排序树而变成有序序列。
插入的结点均为叶子结点，无需移动其他结点。

**不同的插入次序**（关键字的输入顺序）的序列生成不同形态的二叉排序树

#### 删除：

删除某个结点后，还应**保证删除后所得的二叉树仍然满足二叉排序树**
- 因删除结点而断开的二叉链表需要重新链接起来
- 防止重新链接后树的高度增加

**分情况处理**：
- 若被删除的结点是叶子结点，则直接删除该结点
- 被删除的节点只有左子树或只有右子树，用其左子树或右子树替换
- 被删除的结点既有左子树，也有右子树
	- 以中序**前趋**（左子树中最大的结点）值替换，然后再删除该前驱结点
	- 以后继**替换**（右子树值最小），在删除该后继结点
	- 选择前趋或后继应尽量控制树的高度越低越好

## 2. 平衡二叉树

提高**形态不均衡**的二叉排序树的查找效率

平衡化处理
