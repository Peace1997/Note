## 一、简述
线性表是具有相同特性的数据元素的一个有限序列。数据元素之间的关系具有线性关系。


### 线性表的定义：
- 数据对象
- 数据关系
- 基本操作（逻辑结构）
	- 初始化（在内存中创建）
	- 销毁（内存中不在）
	- 重置（置为空表，内存中还在）
	- 判断是否为空
	- 获取线性表元素
	- 查找是否有指定元素，返回位序（第一个查找到）
	- 返回前驱/后继元素
	- 线性表指定位置插入/删除
	- 线性表遍历


### 存储结构实现
- 顺序表
- 链表
	- 单链表
	- 循环链表
	- 双链表



## 二、线性表的顺序存储结构（顺序表）

### 1. 定义
**把逻辑上相邻的元素存储在物理上相邻的存储单元上**。

依次存储，地址连续，占用一片连续的存储空间，**中间没有空出存储单元**。知道某个元素的存储位置就可以计算其他元素的存储位置。

**结点构成**：数据域

#### 特点
顺序表的逻辑结构与存储结构一致
可以快速计算出每个数据元素的存储地址，即访问每个元素所花时间相同。

地址连续、依次存放、**随机存取**、类型相同

查找、插入、删除算法的平均时间复杂度为 O (n)，空间时间复杂度O(1)

#### 优缺点
**优点：**
- 存储密度大（结点本身所占存储量/结点结构所占存储量 =1），存储密度越大存储利用率越高。
- 可以随机存取表中任一元素 O (1)
**缺点：**
- 插入、删除某一元素时，需要移动大量元素 O (n)
- 浪费存储空间（需要事先指定容量）
- 属于静态存储形式，数据元素的个数不能自由扩充


### 2. 数据结构
顺序存储表示：**数组**。顺序表表长可变，数组长度不可动态定义，用一变量表示顺序表的长度属性。

```c
# 数组静态分配
# define LIST_INIT_SIZE 100  //线性表存储空间的初始分配量，但只用其中一部分
typedef struct{
	   ElemType elem[LIST_INIT_SIZE]; //ElemType 数据类型；elem这个数组名表示存放首元素elem[0]的地址（首地址）
	   int length; //当前长度
}SqList;

# 数组动态分配
typedef struct{
	   ElemType *elem; //指针表示，需要在内存中分配空间
	   int length; //当前长度
}SqList;
SqList L;
L.elem =(ElemType*)malloc(sizeof(ElemType*MAXSIZE));
```

**指针指向的是地址**
``` c
float a,b,*p //定义指针p
a=1
p = &a //指定p指针指向的地址
b = *p //获取p指针指向的内容
```



### 3. 参数传递
- **传值**：实参和形参各用自身空间，形参变，实参不变
	- 参数为整型、实型、字符型等
- **传地址**：共用同一地址（空间），一般来说，形参变，实参变
	- 参数为**指针**变量（不一定形参会影响实参变换）—— 特殊情况
		- 当利用指针修改指向元素的内容时，形参变，实参也会变 
		- 仅改变指针指向的地址时，形参变，实参不会变
	- 参数为**引用**类型
		- 传递引用与传递指针效果是一样的，形参变化实参也会变化
		- 引用类型作为形参，在内存中没有产生实参副本。
		``` c++
		// 举例1
		int i = 5
		int &j = i //i，j共用同一地址；j变i也变

		//举例2
		swap(i)
		void swap(float& j)
		```
	- 参数为**数组名**（数组首地址 ）


### 4. 顺序表的基本操作

- 顺序表的**创建**
```c
void InitList_Sq(SqList &L){
	L.elem = new ElemType[MAXSIZE];
	if(!L.elem) exit(1)
	L.length = 0;
}
```
- 顺序表的**销毁**
``` c
void DeleteList_Sq(SqList &L){
	if (L.elem) delete L.elem;
}
```
- 顺序表的**清空**
```c
void DeleteList_Sq(SqList &L){
	L.length =0;
}
```
- 顺序表的**存取**；O(1) 
- 顺序表的**查找**；O (n )； 平均查找长度：$ASL=\sum\limits_{i=1}^{n} P_iC_{i}=\sum\limits_{i=1}^{n} \frac{1}{n}i = \frac{n+1}{2}$
- 顺序表的**插入**：O (n)；平均移动次数：$\frac{n}{2}$
	- 判断插入位置是否合法 \[0,n+1]
	- 判断顺序表存储空间是否已满
	- 第i个位置插入
		- 插入位置在最后：直接赋值
		- 插入位置在中间：将第n至i位的元素依次向后移动一个位置，空出第i各位置
		- 插入位置在最前面：所有元素都要往后移动
	- 表长加1
- 顺序表的**删除**：O(n) ；平均移动次数：$\frac{n-1}{2}$
	- 判断删除位置是否合法 \[0, n]
	- 删除第 i 个位置
		- 删除位置在最后：直接删除
		- 删除位置在中间：将第i至n的元素依次向前移动一个位置
		- 删除位置在最前面：所有元素依次前移
	- 表长减1 

 
## 三、线性表的链式存储结构 （链表）

### 1.定义
用一组**物理位置任意的存储单元**来存放线性表的数据元素；链表中元素的**逻辑次序和物理次序不一定相同**。

==**结点构成**：数据域+指针域（记录下一个元素指向的地址）==

单链表可以由头指针名称表示



#### 特点
- 存储器中的位置是任意的
- **顺序存取法**：访问时只能通过头结点进入链表，所以访问第一个和最后一个结点所花时间不同

#### 优缺点
**优点**：
- 结点空间可以动态申请和释放
- 插入和删除时不需要移动，通过结点指针完成
**缺点**：
- 存储密度较少（小于 1），需要额外空间存储指针域
- 非随机存取结构，不方便存取

#### 头指针、头结点和首元结点
**头指针**：指向链表中第一个结点的指针
**首元结点**：链表中存储第一个元素的结点
**头结点**：链表的首元结点之前附设的一个结点
	特点：数据域可为空，也可放线性表长度等附加信息，但是**头节点不算入链表长度**
	好处：
		- 便于首元节点的处理，链表第一个位置操作和其他位置一致，无须特殊处理
		- 便于空表和非空表的统一

![[Pasted image 20220918121258.png]]


#### 空表：
- 无头结点，头指针为空
- 有头结点，头节点的指针域为空


### 2. 链表

结点：数据元素的存储映像，由数据域和指针域构成
**链表**：n 个结点由指针链组成一个链表；它是线性表的链式存储映像。


### 3. 单链表

#### 定义
又称线性链表。
结点只有**一个指针域**的链表

带头结点的单链表
![[Pasted image 20220918122622.png]]

单链表由表头唯一确定，所以**单链表可以用头指针的名字命名**。


#### 存储结构

```c
typedef struct Lnode{ //声明结点的类型和指向节点的指针类型；嵌套定义
	Elem Type data;   //数据域
	struct Lnode *next //指针域
}Lnode,*LinkList //Lnode表示一个结点，LinkList 为指向结构体Lnode的指针类型


// 这两种方式等价，但常用于不同场合
LinkList L; //定义链表L；
LNode *p;  // 定义结点指针p

```


#### 基本操作
1. 单链表初始化
	- 生成新结点作为头结点，用头指针 L 指向头结点
	- 将头节点的指针域置空
```c
typedef int Status; //函数类型
typedef char ElemType;  //元素类型

Status InitList L(LinkList &L){ //加&说明要对L修改，不加&不会修改原L
	L = new LNode; // <-c++  or c-> L=(LinkList) malloc(sizeof(Lnode));
	L->next = NULL
	return 1;
}

```

2. 单链表销毁
	- 依次删除每个结点
```c
Status DestortList_L(LinkList &L){
	Lnode *p; //or LinkList p; 中转
	while (L){
		p = L;
		L = L->next;
		delete p;//  <-c++  or c-> free ；注意c和c++要前后对应
	}
}
```

3. 清空单链表
	- 头指针和头结点仍存在
	- 依次释放每个结点，头节点指针域设为空
``` c
Status ClearList_L(LinkList &L){
	Lnode *p,*q*; //or LinkList p,q; q用于存储p指向的下一结点，用于中转移
	p = L->next //
	while (p){
		q = p->next;
		delete p;
		p = q;
	}
	L-next = NULL
	
}
```
4. 单链表表长
5. 取值:O(n)
	- 根据位置序号，从头指针出发逐个查找
6. 查找: O(n)
	- 按值查找：返回该值所在位置
7. 插入:O(n)
	- 先查找到要删除位置的**上一个**结点位置p
	- s->next = p->next
	- p->next =s
8. 删除:O(n)
	- 先查找要删除节点的**上一个**结点位置 p
	- q = p->next
	- p->next = q->next 
	- delete q 
9. 单链表的建立
	- 前插法：元素插入在链表头部，从最后一个结点开始，依次将各结点插入到链表前端
	- 后插法：元素插在链表尾部，需要一个尾指针指向链表的尾结点
```c

// 头插法 O(n)

L = new LNode; //L = (LinkList)malloc(sizeof(LNode))
L->next =NULL //创建头结点
for(i=n;i>0;--i){
	p = new LNode;
	cin>>p->data; //c: scanf(&p->data);
	p->next = L->next;
	L->next = p;
}

//尾插法 


L = new LNode;
L->next = NULL
r = L
for (i=0;i<n;++i){
	p = new LNode;
	cin>>p->data;
	p ->next = NULL
	r->next = p
	r = p
}

```


### 4. 循环链表

#### 定义
首尾相接的链表，即表中最后一个结点的指针域指向头结点，整个链表形成一个环

加入头结点
![[Pasted image 20220918170641.png]]
**优点**：从表中任一结点出发，均可找到表中其他结点

**循环条件**：需要从单链表的 `p!=NULL or p->next!=NULL` 判断是否为空改为 `p!=L or p->next!=L` 判断是否为头指针


**尾指针**比头指针表示循环链表容易找到首尾位置:O (1)

#### 尾指针的循环链表合并
- p存Ta表头结点
- Ta 表尾连接Tb表头
- 释放 Tb 表头结点
- Tb表尾连接p
![[Pasted image 20220918171453.png]]


### 5. 双链表

#### 定义
结点有两个指针域的链表，在单链表的基础上增加一个指向其直接前驱的指针域`prior`

#### 数据结构
```c
typedef struct DuLNode{
	Elemtype data;
	struct DuLNode *prior,*next;
}DuLNode,*DuLinkList
```

![[Pasted image 20220918172044.png]]

#### 双向循环链表

和单链表类似，让头结点的前驱链表指向链表最后一个结点，让最后一个结点的后继指针指向头结点
![[Pasted image 20220918172221.png]]


#### 双向链表的操作

双向链表的查找操作同单链表

**双向链表的插入**
```c
//插入s,先找到插入节点的位置的后一结点位置 p
s= new DuLNode; s->data =e;
s->prior = p->prior
p->prior->next  = s
s->next = p
p->prior = s
```
![[Pasted image 20220918172837.png]]

**双向链表的删除**
```c
//查找要删除的结点位置p

p->prior->next = p->next
p->next->prior = p->prior
delate p

```


## 四、顺序表和链表比较

![[Pasted image 20220918174202.png]]


链表：
==**随机存储，顺序存取**==

顺序表：
==**顺序存储，随机存取**==

练习：

线性表合并
有序表合并
- 顺序表
- 链表
多项式相加运算
稀疏多项式运算