# 一、 基本概念
G = (V, E)
- V：顶点的有穷非空集合
- E：边的有穷集合

**有向图**：每条边都是无方向的
**无向图**：每条边都是有方向的
**完全图**：任意两个点都有一条边相连
**网**：边/弧带权的图
**关联**（依附）：边/弧与顶点之间的关系

**顶点的度**：与该顶点相关联的边的数目
> 在有向图中，顶点的度等于该顶点的入度和出度之和
> v的入度：以 v 为终点
> v的出度：以 v 为始点

**有向树**：当有向图中仅有一个顶点的入度为 0，其余顶点的入度均为 1


**路径**：接续的边构成的顶点序列
**路径长度**：路径上边或弧的数目/权值之和
**回路**（环）：第一个顶点和最后一个顶点相同的路径
**简单路径**：除路径起点和终点可以相同外，其余顶点均不相同的路径
**简单回路**（环）：除路径起点和终点相同外，其余顶点均不相同的路径

![[graph1.png]]

有向图中，1->3
**弧头**：箭头指向; 3
**弧尾**：箭头始发; 1


**连通图（强连通图）**：从无（有）向图 G=(V,{E})，若对于任何两个顶点 v、u 都存在从 v 到 u 的路径，则称 G 是连通图（强连通图）

**连通分量**（强连通分量）：无（有）向图 G 的**极大（强）连通子图**称为 G 的（强）连通分量
>极大连通子图：该子图是 G 连通子图，将 G 的任何不在该子图中的顶点加入，子图不在连通。

**极小连通子图**：该子图是 G 的连通子图，在该子图中删除任何一条边，子图不在连通。

**生成树**：包含无向图 G 的所有顶点的极小连通子图。

**生成森林**：对非连通子图，由各个连通分量的生成树的集合

# 二、图的存储结构


数组表示法（邻接矩阵）
链式存储结构（多重链表）
- 链接表
- 邻接多重表
- 十字链表

## 1. 邻接矩阵


顶点表（记录各个顶点信息）
邻接矩阵（表示各个顶点之间关系）


无向图邻接矩阵是对称的
存储空间O（$n^2$）

### 数据结构
```c
#define MaxInt 32767 //极大值
#define MVMum 100 //最大顶点数
typedef char VerTexType; //设顶点的数据类型为字符型
typedef int ArcType; //假设边的权值类型为整型

typedef struct{
	VerTexType vexs[MVNum]; //顶点表
	ArcType arcs[MVNum][MVNum]; //邻接矩阵
	int vexnum,arcnum; //图的当前点数和边数
}AMGraph;
```

### 评价
- 直观、简单、好理解
- 方便找任一顶点的所有邻接点
- 方便计算任一顶点的度
- 常用于稠密图

- 不便于增加和删除顶点
- 浪费空间：不适用于稀疏图
- 浪费时间：统计稀疏图中有多少边


## 2. 邻接表

顶点：按编号顺序将顶点数据存储在**一维数组**中
关联同一顶点的边（以顶点为尾的弧）：用**线性链表**存储
- 邻接点域：存放与 v 邻接的顶点在表头数组中的位置
- 链域：指示下一条边或弧
- info（备用）：存储权

### 性质

- **邻接表不唯一**（链域顺序可以变）
- 存储空间O（n+2e）
- **找出度容易，找入度难，逆邻接表相反**。
- 当邻接表的存储结构形成后，图便唯一确定。

### 数据结构
```c

//顶点的结点结构
typedef struct VNode{
	VerTExType data //顶点信息
	ArcNode * firstarc;//指向第一条依附该顶点的边的指针
}VNode,AdjList[MVNum]; //AdjList 表示邻接表类型


//弧（边）的结点结构
#define MVNum 100
typedef struct ArcNode{
	int adjvex;
	struct ArcNode * nextarc;
	OtherInfo info;
}ArcNode

// 图的结构定义
typedef struct{
	AdjList vertices; //数组
	int vexnum,arcnum; 顶点数和弧数
}ALGraph;

```

建立邻接表
- 建立顶点表（顶点结构）
- 建立邻接表（边结点结构 ）

### 评价
- 方便找任一顶点的邻接点
- 节约稀疏图的空间

- 不方便检查任一顶点存在边

## 3. 十字链表

解决**有向图**邻接表求结点度困难的问题，可以看成是有向图和邻接表和逆邻接表结合起来的形成的一种链表。

顶点节点、边（弧）增加多一个指针域
![500](graph2.png)

## 4. 邻接多重表

解决**无向图**每条边都要存储两遍的缺点
![](graph3.png)



# 三、图的遍历

图中可能存在**回路**，因此需要增加一个**辅助数组**来避免重复访问。

深度优先搜索（DFS）
广度优先搜索（BFS）

## 深度优先搜索

顶点访问次序是不唯一的

连通图的深度优先遍历类似于树的**先根遍历**


### 实现方式

**递归**实现、**堆栈**实现
- 邻接矩阵
- 邻接表

## 广度优先遍历

连通图的广度优先遍历类似于树的**层次遍历**

### 实现方式

**队列**实现
- 邻接矩阵
- 邻接表 

# 四、图的应用

## 1. 最小生成树

### 生成树
所有顶点均由边连接在一起，但**不存在回路**的图。一个图可以有许多棵不同的生成树。

#### 特点
- 生成树的顶点个数与图的**顶点个数相同**
- 生成树是图的**极小连通子图**，去掉一条边则非连通。
- 一个有 n 个顶点的连通图的生成树有 n-1 条边
- 在生成树中再加一条边必然形成回路
- 在生成树中任意两个顶点间的路径是唯一的


#### 实现

深度优先生成树
广度优先生成树

### 最小生成树

最小生成树：给定一个无向网络，在该网的所有生成树中，使得**各边权值之和的最小**的那棵生成树称为该网的最小生成树，也叫**最小代价生成树**。

#### MST 性质
Mininum Spanning Tree
一个顶点所对应的最小权值的边，该边必存在最小生成树中



#### 应用
- n 个城市建立通信网，如何选择 n-1 条路线，使总费用最小。

#### 构造最小生成树

##### 普里姆（Prime）算法

每次找一个**顶点**，这个顶点是 U 集合到 U-V 集合中对应权值最小的

![500](graph4.png)

##### 克鲁斯卡尔（Kruskal）算法
思路与 Prime 基本相同，直接**贪心**选择最小的**边**，需要避免成环。
构造的最小生成树不一定唯一

![500](graph5.png)


**两个算法对比**：

![500](graph6.png)

## 2. 最短路径

两个地点的最短（权值之和最小）路径

### 最短路径 VS 最小生成树
最短路径不一定包含所有顶点，也不一定包含n-1条边

### 应用
- 两点间最短路径
- 某源点到其他各点最短路径

### Dijkstra 算法
解决单源点到其他所有点的最短路径；

按**路径长度**递增次序产生最短路径。不断加入可选点，在判断。

![500](graph7.png)

![500](graph8.png)

每次以一个顶点为源点，重复执行Dijkstra算法n次，即可解决所有顶点间的最短路径

### FLoyd 算法 

解决所有顶点间的最短路径

**算法思想**：
- 逐个顶点试探
- 从 $v_i$ 到 $v_j$ 的所有可能存在的路径中
- 选出一条长度最短的路径

![500](graph9.png)

## 3. 拓扑排序 & 关键路径

**有向无环图**（DAG）：无环的有向图

通常描述一个工程或系统的进行过程，子工程称为**活动**

### AOV 网 —— 解决拓扑排序
**顶点**表示活动，弧表示活动之间的优先制约关系

特点：
- 若从 i 到 j 有一条有向路径，则 i 是 j 的前驱，j 是 i 的后继
- 若 <i,j> 是网中有向边，则 i 是 j 的直接前驱；j 是 i 的直接后继
- 不允许有回路


### AOE网 —— 解决关键路径
**边**表示活动，以顶点表示活动的开始或结束时间。


### 拓扑排序

![](graph10.png)

#### 应用：检测 AOV 网中是否存在环：

拓扑排序后，有未被排序的顶点，则 AOV 网必存在环

### 关键路径

**路径长度最长的路径**
> 路径长度：路径上各活动持续时间之和


把工程计划表示为**边**表示活动的网络，用**顶点**表示事件，**弧**表示活动，弧的**权**表示活动持续时间。事件表示在它之前的活动已经完成，在它之后的活动可以开始。

把工程计划表**抽象**为有向图：
![[graph11.png]]

**源点**：入度为0的顶点
**汇点**：出度为 0 的顶点

 
![](graph12.png)


计算步骤
![](graph13.png)

在计算 ve、vl 时，i —>j
计算 e、l 时，j —>k

#### 性质
- 若网中有几条关键路径，则需要加快同时在几条关键路径上的关键活动
- 如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程时间，但是**不能缩短太多**，否则会改变原有关键路径。