串：内容受限的线性表
数组：线形结构的推广
广义表：操作受限的线性表

# 串

内容受限的线性表
零个或多个任意字符组成的有限序列。

**子串**：任意个连续字符组成的子序列
**主串**：包含子串的串相应的称为主串
**子串位置**：子串第一个字符在主串的位置


案例：字符串的匹配



```c

```


## 顺序串
串的顺序存储
```c
#define MAXLEN 255
typedef struct{
	char ch[MAXLEN+1]; //存储串的一维数组
	int length; //串的当前长度
}SString;

```



## 链串
串的链式存储

由于链式存储：操作方便；存储密度较低
为了提高存储密度，通常在一个存储块放置多个字符，即块链


块链结构：
```c
#define CHUNKSIZE 80 
typedef struct Chunk{
	char ch[CHUNKSIZE];
	struct Chunk *next;
}Chunk;


typedef struct{
	Chunk *head,*tail;//串的头指针和尾指针
	int curlen; //串的当前长度
}Lstring;//字符串的块链结构


```

## 串的计算

### 串的模式匹配

确定主串中所含子串（模式串）第一个字符在主串的位置

算法种类：BF 算法、KMP 算法


#### BF 算法
简单匹配算法；穷举

从 S （主串）的每一个字符开始依次与 T （模式串）的字符进行匹配；
匹配失败，则回溯。
回溯搜索法

过程：
- 将主串的第 pos 个字符和模式串的第一个字符比较
- 若相等，继续逐个比较后续字符；
- 若不相等，从主串的下一个字符起，重新与模式串的第一个字符比较。

直到主串的一个连续子串字符序列与模式串相等。返回值为 S 中与 T 匹配的子序列第一个字符的序号，即匹配成功。否则，匹配失败，返回值 0.


```c
int Index_BF(SString S,SString T){
	int i=1,j=1;
	while(i<=S.length && j<=T.length){
		if(s.ch[i]==t.ch[j]){
			++i;++j;
		}
		else{
			i=i-j+2;j=1; //主串、子串回溯
		}
	}
	if (j>=T.length) return i-T.length;
	else return 0;
}
```

时间复杂度：O(n * m)

#### KMP

主串 S 的指针 i 不在回溯，j 也不一定要回到首位



```c
int Index_BF(SString S,SString T,int pos){
	int i=pos,j=1; 
	while(i<=S.length && j<=T.length){
		if(s.ch[i]==t.ch[j]){
			++i;++j;
		}
		else{
			j=next[j]; /* i不变，j后退 */
		}
	}
	if (j>=T.length) return i-T.length;
	else return 0;
}

//next[j]计算  ?????
void get_next(SString T,int &next[]){
	i=1;next[1]=0;j=0;
	while(i<T.length){
		if(j==0 || T.ch[i]==T.ch[j]){
			++i;++j;
			next[i]=j;
		}
		else
			j=next[j];
	}
}

```

next [j]的计算：

$$
\text { next[j] }\left\{\begin{array}{l}

{\text 0， j=1} \\
{\text k，1<k<j  且满足p_1p_2...p_{k-1} = p_{j-k+1}...p_{j-1}} \\
{\text 1，其他情况}
\end{array}\right.
$$

# 数组

按一定格式排列起来的，具有相同类型的数据元素的集合

线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。

**结构固定**，维数和维界不再改变，因此**不做删除、插入**。通常不用链式存储。  

## 顺序存储

行优先（主）、列优先

存储单元是一个一维的，而数组是个多维结构，用一组连续存储单元存放数组的数据元素就有个次序约定问题。

矩阵压缩存储：多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间。
- 对称矩阵、对角矩阵、三角矩阵、稀疏矩阵（三元组、十字链表 ）


# 广义表

广义表是 n 个元素的有限序列，其中每一个 $a_i$ 或者是原子，或者是一个广义表。

当广义表 A 非空时，称第一个元素 $a_1$ 为 A 的表头，称其余元素 $a_2,a_3,...,a_n$ 组成的表为 A 的**表尾**。

广义表中的数据元素有相对次序；一个直接前驱和一个直接后继。
广义表的长度定义为最外层所包含元素的个数。
广义表深度定义为该广义表展开后所包含括号的重数。
广义表可以为其他广义表**共享**
广义表可以是一个**递归**的表。
广义表是多层次结构。

注：广义表的深度是无穷值，长度是有限值。

## 存储结构

广义表中的数据元素可以具有不同的结构，难以用顺序存储表示，所以通常采用链式存储。
由于列表中的数据元素可能为原子或子表，由此需要两种结构的结点，一种是表结点，用以表示子表，另一种是原子结点，用以表示原子。

案例：病毒感染监测（模式匹配；）

