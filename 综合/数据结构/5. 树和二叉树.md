
# 一、树和森林


树是 n 个结点的有限集
树的定义是一个递归的定语你

## 1. 基本术语

结点：数据元素以及指向子树的分支
> 根结点：非空树中无前驱结点的结点

度：结点拥有的子树数
> 树的度：树内各结点的度的最大值

叶子：度为 0 的结点为终端结点，又称为叶子
分支结点：度不为的 0 的结点称为非终端结点


树深：树中结点的最大层次称为树的深度，又称为树的高度
> 根为第一层


有序树：树中结点的各子树从左至右有次序

森林：是 m (m $\geq$ 0) 棵互不相交的树的集合


## 2. 存储结构

###   2.1双亲表示法
通过数组结构表示，存放树的结点，每个结点包含两个域：
- **数据域**：存放结点本身信息
- **双亲域**：指示本节点的双亲结点在数组中的位置

**评价**： 找双亲容易找孩子难
![100](tree3.png)
####  数据结构
```c
// 结点
typedef struct PTNode{
	TElemType data;
	int parent; //双亲位置域
}PTNode;

// 树结构
#define MAX_TREE_SIZE 100
typedef struct{
	PTNoede nodes[MAX_TREE_SIZE];
	int r,n; //根节点的位置和结点个数
}
```



### 2.2孩子链表
把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储。
n 个结点有 n 个孩子链表（叶子的孩子链表为空表）
n 个头指针又组成一个线性表，用顺序表（含 n 个元素的结构数组）存储

**评价**： 找孩子容易找双亲难
![300](tree4.png)
#### 数据结构
```c
// 孩子结点结构
typedef struct CTNode{
	int child;
	struct CTNode *next;
}*ChildPtr;

//双亲结点结构
typedef struct{
	TElemType data;
	ChildPtr firstchild;
}CTBox;

//树结构
#define MAX_TREE_SIZE 100
typedef struct{
	CTBox nodes[MAX_TREE_SIZE];
	int n,r; //结点数和根结点位置
}CTree;
```


#### 带双亲的孩子链表

![300](tree5.png)

### 2.3 孩子兄弟表示法
aka：二叉树表示法、二叉链表表示法

实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点。

####  数据结构
```c
typedef struct CSNode{
	int child;
	struct CSNode *firstchild,*nextsibling;
}CSNode,*CSTree;
```

![500](tree6.png)


## 3. 树与二叉树的转换

将**二叉链表**作为媒介
给定一棵树，可以找到唯一的一棵二叉树与之对应

类似**孩子兄弟表示法**；

树转二叉树：兄弟相连留长子
二叉树转树：左孩右右连双亲，去掉原来右孩线

## 4. 树与二叉树转换

森林转二叉树：

![[tree7.png]]

二叉树转森林

去掉全部右孩线，孤立二叉在还原


## 5. 树的遍历

### 先根遍历、后根遍历、层次遍历
**先根遍历**：先根，后子树
**后根遍历**：先子树，后根
**层次遍历**：从上到下，从左到右

## 6. 森林的遍历

![[tree8.png]]

### 先序遍历、中序遍历：

**先序遍历**：

若森林不为空，
1. 访问森林中第一棵树的根节点
2. 先序遍历森林中第一棵树的子树森林
3. 先序遍历森林中（除第一棵树之外）其余树构成的森林

依次从左至右对森林中的每一棵树进行**先根遍历**。

**中序遍历：**
若森林不为空，
1. 中序遍历森林中第一棵树的子树森林
2. 访问森林中第一棵树的根节点
3. 先序遍历森林中（除第一棵树之外）其余树构成的森林


依次从左至右对森林中的每一棵树进行**后根遍历**。

![[tree9.png]]
> 注意中序遍历的结果


# 二、 二叉树

## 1. 基本定义

所有的树都能转为唯一对应的二叉树

**特点**：
- 每个结点最多有两个孩子
- 子树有左右之分，次序不能颠倒
>树当结点只有一个孩子时，无需区分左右
- 二叉树可以是空集合，根可以有空的左子树或空的右子树

### 树与二叉树
树：子树没有左右之分
二叉树、有序树:左右有序
二叉树与有序树：在只有一棵树的情况下，二叉树有左右之分、有序树无左右之分

另外：二叉树是有序的，可以为空或一个根节点以及两个分别称为左子树和右子树的互不相交的二叉树组成。

**二叉树不是树的特殊情况**，它们是两个概念。但是有关树的基本术语对二叉树都适用

![500](tree.png)

应用案例：
- 数据压缩问题
- 求解表达式



## 2. 满二叉树
一颗深度为 k 且有 $2^k-1$ 个结点的二叉树

**特点**：
- 每一层都满
- 叶子节点全部在底层

## 3. 完全二叉树
深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号为1～n的结点一一对应时，称之为完全二叉树。

**特点**：
- 叶子只可能分布在层次最大的两层上
- 对任一结点，如果其右子树的最大层次为 i，则其左子树的最大层次必为 i 或 i+1



## 4. 二叉树的性质
1.在二叉树的第 i 层最多有 $2^{i-1}$ 个结点 ($i \geq 1$)，最少有 1 个结点
2.深度为k的二叉树至多有$2^k-1$个结点，最少有k个结点
3.对任何一颗二叉树T，如果其叶子数为$n_0$，度为的2的节点数为$n_2$，则$n_{0}=n_{2}+1$

4.具有 n 个结点的完全二叉树的深度为 $\left\lfloor\log _{2}n\right\rfloor+1$ ；表明完全二叉树结点数与深度关系
5.表明完全二叉树双亲结点与孩子结点编号之间的关系。
(1) 如果 $i=1$ ，则结点 $i$ 是二叉树的根，无双亲；如果 i $>1$ ，则其双亲是结点 $\lfloor i / 2\rfloor$ 
(2) 如果 $2 i>n$ ，则结点 $i$ 为叶子结点，无左孩子；否则 其左孩子是结共 2i 
(3) 如果 $2 i+1>n$ ，则结点 $i$ 无右孩子；否则，其右孩 子是结点 $2 i+1$



补：


## 5. 二叉树的顺序存储结构

实现：按**满二叉树**的结点层次编号（编号停在最后一个结点），依次存放在二叉树中的数据元素。结点间关系蕴含在其存储位置中。
> 非满二叉树的中间节点留空，方便恢复


缺点：浪费存储空间，适合于满二叉树和完全二叉树。


### 数据结构

```c
#define MAXTSIZE 100;
Typedef TElemType SqBiTree[MAXTSIZE];
SqBiTree bt;
```



满二叉树和完全二叉树在顺序存储方式下可以**复原**

## 6. 链式存储结构


### 数据结构

#### 二叉链表

```c
typedef struct BiNode{
	TElemType data;
	struct BiNode *lchild,*rchild;//左右孩子指针
}BiNode,*BiTree
```

在n个节点的二叉链表中，有n+1个空指针域



#### 三叉链表

增加了双亲结点。
```c
typedef struct BiNode{
	TElemType data;
	struct BiNode *lchild,*parent,*rchild;//左孩子、双亲、右孩子 指针
}TriNode,*TriTree
```

## 7. 遍历二叉树

### 先、中、后序遍历
若二叉树为空，则空操作

先序 (根) 遍历：根左右
中序遍历：左根右
后序便利：左右根

**三种算法的访问路径是相同的**，只是访问结点的时机不同。

已知二叉树的  先序和中序 // 中序和后序  ，可以构造出相应的二叉树，而知道前序和后序则无法确定

**时间效率：**

时间复杂度：O (n) ，每个结点只访问一次
空间复杂度：O (n) ，**栈**占用的最大辅助空间（只有右子树时）

**实现：**
递归算法 + 非递归算法（栈）

### 层次遍历

从上到下、从左到右的顺序访问每一个结点
通过**队列**实现（顺序循环队列）

### 二叉树遍历算法的应用

#### 二叉树的建立

 #### 复制二叉树 
- 如果是空树，递归结束
- 否则，申请新结点空间，复制根结点
	- 递归复制左子树
	- 递归复制右子树
	
####  计算二叉树的深度
- 如果是空树，则深度为 0；
- 否则，递归计算左子树深度记为 m，递归计算右子树深度记为 n，二叉树的深度则为 m 与 n 的较大者加 1

####  二叉树结点的总个数
- 如果是空树，则节点为 0；
- 否则，结点个数为左子树的结点个数 + 右子树的结点个数 +1

#### 二叉树叶子结点数
- 如果是空树，则节点为 0；
- 否则，结点个数为左子树的结点个数 + 右子树的结点个数



## 8. 线索二叉树

利用二叉链表中的空指针域
如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其**前驱**；
如果某个结点的右孩子为空，则将空的左孩子指针域改为指向其**后继**，

改变指向的指针成为**线索**


#### 数据结构
```c
typedef struct BiThrNode{
	int data;
	int ltag,rtag; //0：有孩子；1:无孩子
	struct BiThrNode *lchild,*rchild;
}BiThrNode,*BiThrTree;
```


增加一个头结点：
- ltag=0，lchild 指向根结点
- ltag=1，rchild 指向遍历序列的最后一个结点
遍历序列中第一个节点的 lc 域和最后一个节点的 rc 域都指向头结点。

![500](tree2.png)


# 三、 哈夫曼树
哈夫曼树（最优二叉树）

## 基本概念

**判断树**：用于描述分类过程的二叉树
**路径**：从树中一个结点到另一个结点之间的分支
**结点的路径长度**：两个结点间路径上分支数
**树的路径长度**：从根到每一个结点的路径长度之和

结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树

**权**：将树中结点赋给一个有着某种含义的数值
**结点的带权路径长度**：从根节点到该结点之间的路径长度与该结点的权的乘积
**树的带权路径长度**：树中所有叶子结点的带权路径长度之和



**哈夫曼树**：带权路径长度最短的二叉树（度相同）

## 性质

满二叉树不一定是哈夫曼树
哈夫曼树中权越大的叶子离根越短
具有相同带权节点的哈夫曼树不唯一
哈夫曼树的结点度为 0 或 2，没有度为 1 的结点
包含 n 个叶子结点的哈夫曼树中共有 2n-1 个节点（度为0：n ，度为2：n-1（n-1次合并））


## 哈夫曼树的构造

贪心算法：构造哈夫曼树时首先选择权值小的叶子结点

1. 构造森林全是根
2. 选用两小造新树
3. 删除两小添新人
4. 重复 2、3 剩单根

![500](tree10.png)


存储：顺序表、链表

### 数据结构

通过顺序表实现

```c
typedef struct{
	int weight;
	int parent,lch,rch;
}HTNode,*HuffmanTree
```

## 哈夫曼编码

**前缀编码**：要设计长度不等的编码，则必须使任一字符的编码都不是另一个字符的编码的前缀。

**哈夫曼编码**：总长最短的前缀码

出现概率越大，编码越短。
左 0 右 1 

![500](tree11.png)

**性质：**

前缀编码：因为到达叶子结点的编码都是不同的
长度最短（最优前缀码）：哈夫曼树是带权路径最短的，故字符编码的总长最短

