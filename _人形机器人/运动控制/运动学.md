
# 1. 运动学

机器人运动学（**Kinematics**）是研究机器人运动关系的学科，主要关注**位置、速度和加速度**，而不涉及运动的力或动力学（即不考虑质量、惯性和力的影响）。运动学主要分为**正向运动学（FK, Forward Kinematics）** 和 **逆向运动学（IK, Inverse Kinematics）**，并涉及**雅可比矩阵**（Jacobian）用于速度和力的转换。

---

## 1.1 机器人运动学分类

机器人运动学主要分为以下三类：

1. **正向运动学（FK）**：已知关节变量（关节角度或位移），求解机器人末端执行器（EE, End Effector）的位置和方向。
2. **逆向运动学（IK）**：已知末端执行器的位置和方向，求解对应的关节变量。
3. **微分运动学（Differential Kinematics）**：研究机器人速度和加速度之间的关系，通常使用**雅可比矩阵（Jacobian）** 进行描述。

---

## 1.2 机器人正向运动学（FK）

正向运动学描述了关节变量 $\mathbf{q}$ 如何映射到末端位置$\mathbf{p}_{EE}$ 和方向 $\mathbf{R}_{EE}$。  
假设机器人有 nn 个自由度（DOF），关节变量为：
$$\mathbf{q} = [q_1, q_2, ..., q_n]^T$$
则末端执行器的位置和方向可以通过变换矩阵 TT 表示：

$$T = T_1(q_1) T_2(q_2) \dots T_n(q_n)$$

其中 $T_i(q_i)$ 是每个关节的变换矩阵，通常采用 **Denavit-Hartenberg (DH) 参数** 来描述。

最终，机器人末端的位置和方向可以表示为：

$$\mathbf{p}_{EE} = f(\mathbf{q}) $$
$$
\mathbf{R}_{EE} = R(\mathbf{q})
$$

其中：

- $\mathbf{p}_{EE} \in \mathbb{R}^3$ 表示末端位置。
- $\mathbf{R}_{EE} \in \mathbb{R}^{3 \times 3}$ 是末端的旋转矩阵。

 ***示例：简单的 2DOF 机械臂***

对于一个二维 2DOF 机械臂：

- 关节变量 $\mathbf{q} = [q_1, q_2]$
- 连杆长度$l_1, l_2$
- 末端位置计算：
$$x = l_1 \cos q_1 + l_2 \cos (q_1 + q_2)
$$$$
y = l_1 \sin q_1 + l_2 \sin (q_1 + q_2)$$

---

## 1.3 机器人逆向运动学（IK）

逆向运动学是正向运动学的逆过程，即已知末端位置 $\mathbf{p}_{EE}$，求解对应的关节角度 $\mathbf{q}$。IK 通常没有**唯一解**，甚至可能**无解**（当目标超出机器人工作空间时）。

***IK 的求解方法：***

1. **解析解法（Analytical IK）**：适用于简单机械臂，可以直接求解闭式解。
2. **数值解法（Numerical IK）**：适用于复杂机器人，例如 Newton-Raphson 方法、伪逆雅可比法等。
3. **优化方法**：使用优化算法（如 SQP、QP、深度学习）求解约束最优解。

***示例：2DOF 机械臂的逆运动学***
对于一个 2DOF 机械臂，已知末端位置 (x, y)，求解 $q_1, q_2$，这是解析求解的方式：

$$q_2 = \cos^{-1} \left( \frac{x^2 + y^2 - l_1^2 - l_2^2}{2 l_1 l_2} \right) $$
$$
q_1 = \tan^{-1}(y, x) - \tan^{-1} \left(\frac{l_2 \sin q_2}{l_1 + l_2 \cos q_2} \right)
$$

---

## 1.4 机器人微分运动学（速度雅可比）

**微分运动学**研究的是机器人关节速度与末端速度之间的关系。通过**雅可比矩阵（Jacobian Matrix）**，可以将关节空间的速度转换为末端速度。

 ***雅可比矩阵定义***

$$\dot{\mathbf{x}} = J(\mathbf{q}) \dot{\mathbf{q}}$$

其中：

- $\dot{\mathbf{x}} \in \mathbb{R}^6$ 是末端线速度和角速度 $[v_x, v_y, v_z, \omega_x, \omega_y, \omega_z]^T$。
- $\dot{\mathbf{q}} \in \mathbb{R}^n$ 是关节角速度（对于旋转关节）或关节线速度（对于滑动关节）。
- $J(\mathbf{q}) \in \mathbb{R}^{6 \times n}$ 是雅可比矩阵，其计算方式依赖于机器人结构。

 ****雅可比矩阵的物理意义***

- **正向雅可比（Forward Jacobian）**：将关节速度映射到末端速度。
- **逆向雅可比（Inverse Jacobian）**：求解逆运动学中的速度映射，即： $\dot{\mathbf{q}} = J^\dagger(\mathbf{q}) \dot{\mathbf{x}}$其中 $J^\dagger$ 是雅可比的广义逆。

**示例：2DOF 机械臂的雅可比矩阵**

$$J = \begin{bmatrix} - l_1 \sin q_1 - l_2 \sin (q_1 + q_2) & -l_2 \sin (q_1 + q_2) \\ l_1 \cos q_1 + l_2 \cos (q_1 + q_2) & l_2 \cos (q_1 + q_2) \end{bmatrix}$$
$$\begin{bmatrix} \dot{x} \\ \dot{y} \end{bmatrix} = J \begin{bmatrix} \dot{q}_1 \\ \dot{q}_2 \end{bmatrix}$$
---

## 1.5 总结

- **正向运动学（FK）**：从关节角度计算末端位置。
- **逆向运动学（IK）**：从末端位置求关节角度。
- **雅可比矩阵（Jacobian）**：描述关节速度与末端速度的关系。
- **在 MPC 规划足底接触力时**，运动学用于计算足端位置和接触力优化。

在**六自由度（6-DOF）人形机器人**的 **MPC 规划足底接触力**时，运动学用于：

1. **计算足端位置 $\mathbf{p}_{foot}$**，确保足底与地面接触；
2. **计算雅可比矩阵 $J_{foot}$**，用于**优化接触力**；
3. **通过逆运动学（IK）计算关节角度**，将接触力控制转换为关节控制指令。

# 2. 动力学

正向动力学和反向动力学是机器人学中两个核心的概念，分别描述了机器人的运动状态与其控制输入（如关节力矩或位置）的关系：
- **正向动力学**：已知驱动力或力矩，求解关节的加速度、速度和位置。主要用于仿真和运动预测。
- **反向动力学**：已知运动轨迹（位置、速度、加速度），求解所需的力矩或驱动力。主要用于控制和力矩计算。

## 2.1 正向动力学（Forward Dynamics）

正向动力学问题是根据机器人的**关节力矩**或**驱动力**来计算**关节的加速度、速度和位置**。它描述了机器人在给定的驱动力（或力矩）作用下会如何运动，是一种“已知输入求输出”的过程。正向动力学的应用场景包括：

- **运动仿真**：通过给定的力或力矩，计算机器人如何运动，以便模拟和分析其运动过程。
- **运动预测**：根据已知的关节驱动力矩，预测机器人下一步的位置、速度和加速度，帮助规划和评估运动轨迹。
  
数学上，正向动力学的基本形式可以表示为：
$$
M (q) \ddot{q} + C (q, \dot{q}) \dot{q} + G (q) = \tau
$$
其中：
- $M (q)$ 是关节位置 $q$ 的惯性矩阵，
- $C (q, \dot{q})$ 是科氏力和离心力矩阵，
- $G (q)$ 是重力向量，
- $\tau$ 是关节力矩。

根据这些力和力矩，正向动力学求解关节的加速度 $\ddot{q}$，再通过积分获得关节速度 $\dot{q}$ 和位置 $q$。

## 2.2 反向动力学（Inverse Dynamics）

反向动力学问题是已知机器人的**关节位置、速度和加速度**，求解**需要的关节力矩或驱动力**。它描述了要让机器人按指定的轨迹运动所需的控制输入，是一种“已知输出求输入”的过程。反向动力学的应用场景包括：

- **轨迹控制**：根据预定轨迹，计算需要施加的力或力矩，以确保机器人按期望的路径移动。
- **力矩控制**：在精确控制下，通过反向动力学计算得到的力矩来精确施加控制力，维持运动稳定性。
  
数学上，反向动力学也基于相同的动力学方程：
$$
\tau = M (q) \ddot{q} + C (q, \dot{q}) \dot{q} + G (q)
$$
在此公式中，已知 $q$、$\dot{q}$、$\ddot{q}$ 后，通过反向动力学求出满足期望运动的力矩 $\tau$。


人形机器人的动力学参数主要包括质量、惯性、关节位置、力矩和阻尼等属性。这些参数在描述和控制机器人的运动中扮演重要角色。以下是人形机器人动力学中常用的参数：

## 2.3 动力学参数



1. ***几何参数***
   - **关节位置（Joint Position）**：描述关节的空间位置，即关节在全局或局部坐标系中的位置。几何位置对于描述机器人姿态和规划路径至关重要。
   - **连杆长度（Link Length）**：描述相邻关节之间的距离，用于定义机器人结构的尺寸。

 4. ***关节参数***
   - **关节角（Joint Angle）**：描述关节的旋转角度，是机器人姿态的主要控制变量之一。
   - **关节速度和加速度（Joint Velocity and Acceleration）**：描述关节的运动状态，是反向动力学和控制计算的输入参数之一。
   - **关节力矩（Joint Torque）**：表示关节所需的驱动力或力矩，通常是反向动力学的输出，用于实现期望的关节运动。

5. ***摩擦和阻尼参数***
   - **摩擦系数（Friction Coefficient）**：关节的摩擦阻力会影响运动平稳性，通常根据实际情况或实验数据给出。
   - **关节阻尼（Damping Coefficient）**：关节阻尼是关节速度与产生的阻力之间的关系系数，用于模拟关节的能量耗散效果。

6. ***动力学方程参数***
   - **惯性矩阵（Inertia Matrix, $M (q)$）**：描述关节质量对运动的影响，依赖于机器人姿态，影响关节的加速度。
   - **科氏力和离心力项（Coriolis and Centrifugal Forces, $C (q, \dot{q})$）**：描述了机器人在加速时所需克服的离心力和科氏力，主要影响到控制力的计算。
   - **重力向量（Gravity Vector, $G (q)$）**：描述重力对各关节的影响，通常是重力分布在关节上的力矩，用于反向动力学计算。

7. ***接触参数***
   - **接触点位置（Contact Point Location）**：描述脚底等部位与地面或物体接触的具体位置。
   - **接触力和摩擦力（Contact Force and Friction Force）**：模拟机器人在接触时产生的支撑力和摩擦力，是步态规划和稳定性分析的重要参数。

8. ***控制参数***
   - **电机功率和扭矩输出范围**：电机的输出功率和最大力矩决定了机器人动作的速度和力量。
   - **传动比（Gear Ratio）**：影响电机的输出特性，将电机的旋转转化为关节运动。

这些动力学参数共同作用，决定了人形机器人的运动性能和控制难度。精确地获取和设置这些参数，对于构建逼真的机器人模型和实现稳定的控制有至关重要的影响。




## 2.4 惯量

惯性张量和惯性矩都是描述物体旋转惯性的重要物理量，但它们在应用上有一些区别。

### 1. 惯量参数
惯量在力学里指物体对运动状态变化的抗拒程度，在机器人领域，惯量直接影响关节驱动的响应速度、能耗、控制稳定性。

***（1）连杆惯量 vs 电枢惯量***

在机器人驱动系统里，通常要区分两种不同来源的惯量：

(a) 连杆惯量（Link Inertia, $I_\text{link}$）
- 来源：机械结构（大腿、小腿、机身等）的质量分布。
- 依赖 CAD 建模、实验测量
- 决定了机器人在空间运动时的动力学负载。
- 在“全机器人辨识”中，连杆惯量误差会体现为额外的“表观惯量”现象，需要补偿或修正。

(b) 电枢惯量（Armature Inertia, $I_a$）
- 来源：电机转子、齿轮系、输出轴等内部部件的转动惯量。
- 通过传动比折算到关节输出端。
- 在“单关节辨识”中，通常把连杆质量设为 0，让 $I_a$ 吸收所有动力学贡献，从而单独拟合电机侧惯量。
- 在系统辨识时，$I_a$ 还会包含一些补偿效应和建模误差，因此称为“有效电枢惯量”。

假设减速比是 $N$（定义为 **电机转速 : 输出转速**），那么电机端与关节端的惯量关系是：
- **从电机折算到关节端**：
$$I_{a,eq} = N^2 I_a$$
- **从关节端折算到电机端**：
$$I_{link,eq} = \frac{I_\text{joint}}{N^2}$$
⚠️ 注意：因为功率守恒，转矩和转速折算时，惯量会成 **平方倍数** 地放大或缩小。

| 特性          | 连杆惯量 ($I_\text{link}$) | 电枢惯量 ($I_a$) |
| ----------- | ---------------------- | ------------ |
| 来源          | 机器人结构、连杆质量分布           | 电机、齿轮、转子等驱动端 |
| 计算方式        | CAD/实验（摆锤法、并轴定理）       | 电机参数表 + 齿轮折算 |
| 影响范围        | 机器人运动学/动力学耦合           | 单关节的响应、伺服控制  |
| 辨识阶段        | 全机器人辨识                 | 单关节辨识        |
| 在 PACE 中的处理 | 可能低估/需修正[10]           | 作为拟合的基准惯量参数  |

***（2）关节的有效惯量***
机器人关节实际感受到的 **总惯量** $I_{eq}$是电机和连杆两部分的合成：
$$I_\text{eq} = I_{a,eq} + I_\text{joint}$$
也就是：
- 电机转子（折算到输出端）
- 加上连杆本身的负载惯量

这个 $I_\text{eq}$ 就是控制、辨识里最常见的有效惯量。**控制器/辨识时，真正作用在关节动力学里的量是有效惯量 $I_\text{eq}$**。

***（3）惯量大小的影响***
惯量越大，意味着系统更迟钝。
**1. 响应速度**
 - 大惯量→ 大惯量 → 关节加速/减速更慢，需要更大力矩。
 - 小惯量 → 关节更灵活，但也更容易受到扰动影响。
 
 **2. 控制带宽**
高惯量会降低系统的固有频率，使得在高带宽控制下更难以稳定。  
因此在 RL 训练或辨识时，通常降低 PD 增益，把动力学特性压到低频区间，更容易激励并拟合

 **3. 能耗与稳定性**
大惯量会增加运动时的能耗（尤其是高频动作）。
但惯量也能起到“低通滤波”作用，抑制高频噪声和抖动。

 **4. 运动学/动力学耦合**
 在全机器人系统中，关节与连杆惯量叠加，还会引入耦合效应，例如 腿在空中摆动时基座的惯量贡献

### 2. 惯性张量（Inertia Tensor）

惯性张量是描述物体绕各个轴旋转时的惯性分布的矩阵，是一个 3 x 3 的对称矩阵。它的每个元素都代表物体在不同轴上的惯性属性，**反映了物体质量在各个方向上的分布情况**，**即系统对加速度变化的阻抗**。惯性张量的定义如下：

$$
I = \begin{bmatrix} I_{xx} & I_{xy} & I_{xz} \\ I_{yx} & I_{yy} & I_{yz} \\ I_{zx} & I_{zy} & I_{zz} \end{bmatrix}
$$

其中：
- 对角线元素 $I_{xx}, I_{yy}, I_{zz}$ 是关于各自坐标轴的惯性矩。例如，$I_{xx}$表示仅让关节加速时需要的力矩和加速度的比值，
- 非对角线元素 $I_{xy}, I_{xz}, I_{yz}$ 表示各坐标轴之间的惯性耦合，称为惯性积。例如，$I_{xy}$关节 y 的加速度对关节 x 所需力矩的影响。

惯性张量描述了刚体在三维空间中旋转时的动态行为，广泛用于三维旋转运动的动力学计算。例如在物体绕任意方向旋转时，惯性张量可以帮助计算出角动量和角加速度之间的关系。

### 3. 惯性矩（Moment of Inertia）

惯性矩是惯性张量的特例，通常表示物体绕某一特定旋转轴的旋转惯性。它是惯性张量的对角元素，即 $I_{xx}, I_{yy}, I_{zz}$，用于描述物体绕单个轴的惯性大小。惯性矩通常通过下列公式计算：
$$
I = \int_V \rho (r) \cdot r^2 \, dV
$$
其中：
- $\rho (r)$ 是物体在位置 $r$ 处的质量密度，
- $r$ 是该位置到旋转轴的距离。

>  在二维平面上旋转时，惯性矩和惯性张量等价，因为只有一个惯性矩就可以描述物体的旋转特性。


### 4. 惯性积（Product of Inertia）
**惯性积**（Product of Inertia）是惯性张量中的非对角线元素，用于描述物体质量分布在不同轴之间的耦合关系。惯性积反映了物体在旋转时，由于质量分布不均匀，**在一个坐标轴上旋转会引起其他轴的耦合效应**。惯性积广泛应用于三维物体动力学计算和稳定性分析中。

对于一个质量分布已知的刚体，惯性积定义为：
$$
I_{ij} = - \int_V x_i x_j \, dm
$$
其中：

- $x_i$ 和 $x_j$​ 是刚体内质点相对于 i 轴和 j 轴的坐标，
- $I_{ij}$ 是惯性积，它在惯性张量中位于第 i 行第 j 列和第 j 行第 i 列。

**性质：**
- **对称性**：惯性张量是对称矩阵，因此 $I_{ij} = I_{ji}$ 。
- **坐标依赖性**：惯性积依赖于物体的旋转轴的选择。在某些特定坐标系下（例如主轴系），惯性积可以变为零，使惯性张量对角化。对称物体的惯性积通常为零，意味着对称物体在一个轴上的旋转不会对其他轴产生影响。


## 2.5 动力学方程

人形机器人是**高自由度、多约束的系统**，其动力学方程通常采用**拉格朗日方法或牛顿-欧拉方法**进行推导。动力学可分为：

1. **全身系统动力学（Floating-Base Dynamics）**
2. **质心（CoM, Center of Mass）动力学**


---

### 1. 人形机器人系统动力学方程（全身动力学）

人形机器人是一个**浮动基座系统（Floating-Base System）**，其动力学方程通常表示为：

$$M(q)\ddot{q} + C(q, \dot{q}) \dot{q} + G(q) = S^T \tau + J_c^T f_c$$

其中：

- $q \in \mathbb{R}^{n+6}$：**广义坐标**（包含 6D 浮动基坐标 (即机身位姿） + 关节角度）。
- $M(q) \in \mathbb{R}^{(n+6) \times (n+6)}$：**惯性矩阵**（系统的质量分布）。
- $C(q, \dot{q}) \dot{q} \in \mathbb{R}^{(n+6)}$：**科氏力与离心力项**（Coriolis and Centrifugal）。
- $G(q) \in \mathbb{R}^{(n+6)}$：**重力项**（Gravitational）。
- $S^T \in \mathbb{R}^{n \times (n+6)}$：**选择矩阵**（提取控制关节部分）。
- $\tau \in \mathbb{R}^{n}$：**关节力矩**（Torque）。
- $J_c(q) \in \mathbb{R}^{k \times (n+6)}$：**接触雅可比矩阵**（足端接触）。
- $f_c \in \mathbb{R}^{k}$：**接触力**（Ground Reaction Forces, GRF）。

> **物理意义**：
> 
> - 该方程描述了机器人的整体运动，包括浮动基座（机身）和关节。
> - 右侧两项分别对应：**关节力矩驱动** $S^T \tau$ 和 **足底接触力** $J_c^T f_c$。
> - 当机器人双脚站立时，$f_c$提供的约束力控制机器人平衡。
> - 当机器人单脚支撑或跳跃时，$f_c$ 可能等于零。

---

### 2. 质心动力学方程

全身动力学方程精确，但计算复杂，因此在机器人控制中，我们经常使用**质心动力学（Centroidal Dynamics）**，即：

人形机器人在双足支撑或单足支撑时的**质心动力学**可以表示为：

$$M_{CoM}(\mathbf{x}) \ddot{\mathbf{p}}_{CoM} + C_{CoM}(\mathbf{x}, \dot{\mathbf{x}}) \dot{\mathbf{p}}_{CoM} + G_{CoM}(\mathbf{x}) = J^T_{CoM}(\mathbf{x}) \mathbf{F}_{foot}$$​

其中：

- $M_{CoM}(\mathbf{x}) \in \mathbb{R}^{3 \times 3}$ ：质心的惯性矩阵（通常近似为对角矩阵）。
- $\mathbf{p}_{CoM} \in \mathbb{R}^3$ ：质心的位置。
- $\dot{\mathbf{p}}_{CoM} \in \mathbb{R}^3$ ：质心的速度。
- $\ddot{\mathbf{p}}_{CoM} \in \mathbb{R}^3$ ：质心的加速度。
- $C_{CoM}(\mathbf{x}, \dot{\mathbf{x}})$：科氏力和离心力项。
- $G_{CoM}(\mathbf{x})$ ：重力项。
- $J_{CoM}(\mathbf{x})$：质心对足端的雅可比矩阵。
- $\mathbf{F}_{foot} \in \mathbb{R}^{3}$ ：足底接触力。

假设：

1. **忽略科氏力和离心力**（$C_{CoM}(\mathbf{x}, \dot{\mathbf{x}}) \approx 0$）。
2. **重力项近似为常数**（$G_{CoM}(\mathbf{x}) \approx M_{CoM}g$）。
3. **惯性矩阵 $M_{CoM}$近似为常数**。

那么方程简化为：

$$M_{CoM} \ddot{\mathbf{p}}_{CoM} = J^T_{CoM} \mathbf{F}_{foot} - M_{CoM}$$

$$M_c \dot{v}_c + h_c = \sum J_{ci}^T f_{ci}$$

其中：

- **质心惯性矩阵 $M_c$**：$M_c = \begin{bmatrix} mI & 0 \\ 0 & I_c \end{bmatrix}$ 其中：
    - $m$ 是机器人的总质量。
    - $I_c$ 是质心惯性张量（描述角动量变化）。
- **质心广义速度 $v_c$**： $v_c = \begin{bmatrix} \dot{p}_c \\ L_c \end{bmatrix}$ 其中：
    - $\dot{p}_c$ 是质心的线速度。
    - $L_c$ 是角动量。
- **角动量项 $h_c$**：$h_c = \sum_i (r_i - p_c) \times m_i v_i$ 这项描述机器人围绕质心的角动量。
- **接触点雅可比矩阵 $J_{ci}$**：$J_{ci} = \begin{bmatrix} J_{ci}^v \\ J_{ci}^\omega \end{bmatrix}$ 其中：
    - $J_{ci}^v$ 是质心速度与足端速度之间的雅可比矩阵。
    - $J_{ci}^\omega$ 是角速度相关的雅可比矩阵。
- **足端接触力 $f_{ci}$**：$f_{ci} = \begin{bmatrix} f_{ci}^t \\ f_{ci}^r \end{bmatrix}$ 其中：
    - $f_{ci}^t$ 是接触点的**线性力**（地面反作用力）。
    - $f_{ci}^r$ 是接触点的**力矩**（摩擦力）。

**直观理解**：

- 质心动力学方程更关注机器人整体的线性和角动量，而不关心具体的关节状态。
- 这一方程特别适用于**运动规划和MPC（Model Predictive Control）**，因为它大大简化了计算。

---

### 3. 关系与区别

| 特性    | **全身动力学方程** | **质心动力学方程**           |
| ----- | ----------- | --------------------- |
| 主要变量  | 关节角度 $q$    | 质心位置 $p_c$ 和角动量 $L_c$ |
| 计算复杂度 | 高（需要求解多维矩阵） | 低（仅考虑质心和角动量）          |
| 适用场景  | 低级控制（如逆动力学） | 高级规划（如 MPC）           |

**核心区别：**

1. **全身动力学考虑每个关节的受力，而质心动力学关注整体的动量守恒。**
2. **全身动力学适用于机器人动力学仿真，而质心动力学适用于高层运动控制。**


- **全身动力学方程**精确但复杂，适用于低级控制（如逆动力学）。
- **质心动力学方程**更简洁，适用于轨迹优化和MPC。
- **两者之间的映射**： $M_c \dot{v}_c + h_c = \sum J_{ci}^T f_{ci}$ 质心动力学可以从全身动力学通过去除关节变量并聚合质量-惯性属性得到。

如果你计划用 MPC 进行足底接触力规划，**质心动力学方程**通常是更好的选择，因为它降低了计算复杂度。你需要进一步**离散化该方程**，并在 MPC 约束中考虑足底接触力和摩擦约束。






## 机器人系统质心
机器人系统的总质心位置$\mathbf{p}_{\text{CoM}}$由机器人所有连杆的质心位置和质量加权平均得到：
$$\mathbf{p}_{\text{CoM}} = \frac{\sum_{i=1}^n m_i \mathbf{p}_{ci}}{\sum_{i=1}^n m_i}$$​
其中：

- $\mathbf{p}$​：第 i 个连杆的质心在全局坐标系中的位置。
- 通过正向运动学计算 $\mathbf{p}_{ci} = T_0^i \cdot \mathbf{r}_{ci}$​。


# 3. 雅可比矩阵

在机器人运动控制和规划中，**雅可比矩阵（Jacobian Matrix）** 及其**转置（Jacobian Transpose）** 具有重要的数学和物理意义，尤其是在动力学计算、运动规划和力控制等方面。

---

## 3.1 雅可比矩阵的意义

雅可比矩阵用于描述**关节空间（Joint Space）与笛卡尔空间（Task Space）之间的映射关系**，可以***将关节速度转换为末端执行器的线速度和角速度***。

假设一个机器人有 nn 个自由度，关节角（或关节变量）表示为：

$$\mathbf{q} = [q_1, q_2, \dots, q_n]^T$$

而末端执行器在笛卡尔空间中的位置表示为：

$$\mathbf{x} = [x_1, x_2, x_3]^T$$

那么，末端速度与关节速度的关系由雅可比矩阵 **$\mathbf{J}$** 给出：

$$\dot{\mathbf{x}} = \mathbf{J}(\mathbf{q}) \dot{\mathbf{q}}$$

其中，**雅可比矩阵 $\mathbf{J}(\mathbf{q})$ 是关于关节变量的偏导数矩阵**：

$$\mathbf{J}(\mathbf{q}) = \begin{bmatrix} \frac{\partial x_1}{\partial q_1} & \frac{\partial x_1}{\partial q_2} & \cdots & \frac{\partial x_1}{\partial q_n} \\ \frac{\partial x_2}{\partial q_1} & \frac{\partial x_2}{\partial q_2} & \cdots & \frac{\partial x_2}{\partial q_n} \\ \frac{\partial x_3}{\partial q_1} & \frac{\partial x_3}{\partial q_2} & \cdots & \frac{\partial x_3}{\partial q_n} \end{bmatrix}$$

- **行数**：代表任务空间的维度（通常是3个位置+3个角度，共6维）。
- **列数**：代表机器人自由度（nn）。只让第 i 个关节以单位速度动，末端会怎动，即速度杠杆。

因此，**雅可比矩阵本质上是关节速度到末端执行器速度的变换矩阵**。通过使用运动学库计算雅可比矩阵（`pinocchio`、`RBDL`、`Drake`、`Isaac Gym`）


## 3.2 雅可比矩阵转置的意义

雅可比矩阵的转置 $\mathbf{J}$ 在**力控制**中具有重要意义，特别是在映射**外力到关节力矩**的过程中。

假设末端执行器受到一个笛卡尔空间中的力 $\mathbf{F}$（包括力和力矩）：

$$\mathbf{\tau} = \mathbf{J}^T(q) \mathbf{F}$$

其中：

- **$\mathbf{\tau}$ 是关节力矩（torque）向量**，用于驱动每个关节电机或执行器。
- **$\mathbf{F}$ 是作用在末端的力（包括力矩）**。
- **$\mathbf{J}^T$ 将任务空间的力 $\mathbf{F}$ 映射到关节空间的力矩 $\mathbf{\tau}$**。

这一关系广泛用于：

- **力控制（Impedance Control）**：控制末端力，使机器人能够与环境进行柔顺交互。
- **逆动力学（Inverse Dynamics）**：计算机器人需要施加的关节力矩，以跟踪期望轨迹。
- **仿人机器人步行控制**：计算足端接触地面的反作用力并转化为关节力矩，以保持平衡。


## 3.3 雅可比矩阵与雅可比转置的比较

| 矩阵                       | 主要作用        | 典型应用       |
| ------------------------ | ----------- | ---------- |
| **雅可比矩阵 $\mathbf{J}$**   | 关节速度 → 末端速度 | 运动规划、运动学正解 |
| **雅可比转置 $\mathbf{J}^T$** | 末端力 → 关节力矩  | 力控制、逆动力学   |

在某些优化控制方法（如力控制和仿人机器人控制）中，**雅可比转置方法（Jacobian Transpose Method）** 有时可用于近似求解逆雅可比（即 $\mathbf{J}^{-1}$），避免计算伪逆，提高数值稳定性。

## 3.4 总结

- **雅可比矩阵 $\mathbf{J}$** 主要用于**速度映射**（关节速度到末端速度）。
- **雅可比转置 $\mathbf{J}^T$** 主要用于**力映射**（末端力到关节力矩）。
- 在机器人运动控制、轨迹规划、力控制、仿人机器人步行等应用中，雅可比矩阵是不可或缺的数学工具。

如果你在仿人机器人控制中需要**基于 MPC 计算足端接触力**，你会用到雅可比矩阵来计算足端速度，并用雅可比转置来将地面反作用力转换为关节力矩。这样可以实现机器人稳定行走并跟踪目标速度。



# 4. 牛顿-欧拉方法

## 1. 欧拉动量方程

欧拉动量方程 (Euler's Momentum Equations)的基本形式
**角动量形式（惯性坐标系）：** 
$$\frac{d\mathbf{L}}{dt} = \boldsymbol{\tau}_{ext}$$
> 惯性坐标系：固定在空间中不动的参考坐标系（全局坐标系），通常用$W$表示。不随机器人的运动而变化，牛顿定律在此坐标系中直接成立。

- 方程是线性的
- 没有额外的非惯性项
- 数值计算稳定


**角速度形式（物体坐标系）：**
$$\mathbf{I}\dot{\boldsymbol{\omega}} + \boldsymbol{\omega} \times (\mathbf{I}\boldsymbol{\omega}) = \boldsymbol{\tau}$$
> 固定在物体上（机器人基座）上随之运动的坐标系，通常用$B$表示。跟随物体平动和转动，存在虚拟力（科里奥利力、离心力）。

这个方程描述的是单个刚体的旋转动力学。
- 方程变为非线性
- 坐标系本身在旋转
- 需要考虑科里奥利效应

## 2. 牛顿-欧拉方程
完整形式
牛顿-欧拉方程是牛顿方程（平动）和欧拉方程（转动）的组合：
牛顿方程（线动量守恒）： $$m\ddot{\mathbf{r}}_{CoM} = \sum \mathbf{f}_{ext}$$
欧拉方程（角动量守恒）： $$\frac{d\mathbf{L}}{dt} = \sum \boldsymbol{\tau}_{ext}$$
组合起来就是牛顿-欧拉方程：
$$\begin{bmatrix} m\mathbf{I}_{3×3} & \mathbf{0} \\ \mathbf{0} & \mathbf{I}_{rot} \end{bmatrix} \begin{bmatrix} \ddot{\mathbf{r}}_{CoM} \\ \dot{\boldsymbol{\omega}} \end{bmatrix} + \begin{bmatrix} \mathbf{0} \\ \boldsymbol{\omega} \times (\mathbf{I}_{rot}\boldsymbol{\omega}) \end{bmatrix} = \begin{bmatrix} \mathbf{f}_{ext} \\ \boldsymbol{\tau}_{ext} \end{bmatrix}$$


# 5. 机器人方向

## 1. 欧拉角（Euler Angles）

- **维度**：3
- **含义**：沿三个固定轴（如XYZ或ZYX）**依次**旋转的角度。
- **优点**：
    - 易于理解、可视化。
    - 参数少（3个）。
- **缺点**：
    - 存在万向节死锁（Gimbal Lock）。
    - 非唯一，多个角度组合可能表示同一姿态。
    - 不适用于连续插值、梯度优化。
- **典型应用**：简易运动设定、可视化、低自由度控制器。

>[! 万向节死锁]
>这通常发生在俯仰角（Pitch；Red）为±90°时，此时偏航角（Yaw；Blue）和横滚角（Roll，Green）的旋转轴重合，使得系统无法通过欧拉角准确描述旋转状态。


### 角速度 vs 欧拉角速度

**角速度 (Angular Velocity)**
定义: 刚体在空间中的瞬时旋转速度向量 符号: $\boldsymbol{\omega} = [\omega_x, \omega_y, \omega_z]^T$ 性质:
- 是一个真实的物理向量
- 满足向量加法规则
- 在任何坐标系中都**有明确的物理意义**
    

**欧拉角速度 (Euler Angle Rates)**
定义: 欧拉角随时间的变化率 符号: $\dot{\boldsymbol{\theta}} = [\dot{\phi}, \dot{\theta}, \dot{\psi}]^T$ (roll, pitch, yaw的时间导数) 性质:
- 是参数化表示的导数
- 不是向量，不满足向量加法
- 依赖于欧拉角的定义顺序(如ZYX、XYZ等)


两者的数学关系:
角速度和欧拉角速度通过一个**非线性变换矩阵**相关联：
$$\boldsymbol{\omega} = \mathbf{T}(\boldsymbol{\theta}) \dot{\boldsymbol{\theta}}$$
对于 ZYX 欧拉角(航空序)： $$
\begin{bmatrix} \omega_x \\ \omega_y \\ \omega_z \end{bmatrix} = \begin{bmatrix} 1 & 0 & -\sin\theta \\ 0 & \cos\phi & \cos\theta\sin\phi \\0 & -\sin\phi & \cos\theta\cos\phi \end{bmatrix} \begin{bmatrix} \dot{\phi} \\ \dot{\theta} \\ \dot{\psi} \end{bmatrix}$$

关键区别:
1. 奇异性: 当$\theta = \pm 90°$时，$\mathbf{T}$矩阵奇异(万向锁)
2. 非线性: 变换矩阵依赖于当前姿态
3. 物理意义: $\omega$有直接物理意义，$\dot{\theta}$只是参数变化率

---

## 2. 轴角（Axis-Angle）

- **维度**：3（单位轴向量×旋转角度）。
- **含义**：绕某单位轴旋转某角度。
- **优点**：
    - 直观表示任意旋转。
    - 适用于小角度误差表达。
- **缺点**：
    - 180°旋转存在方向模糊。
    - 数值优化时可能出现不连续跳变。
- **典型应用**：轨迹平滑、旋转差异计算。

---

## 3. 四元数（Quaternion）

- **维度**：4
- **含义**：用四个参数 $(w, x, y, z)$ 表示旋转。
- **优点**：
    - 无奇异性，无 Gimbal Lock。
    - 易于姿态插值（如SLERP）。
    - 计算高效。
- **缺点**：
    - 双覆盖（$q$和$-q$表示同一旋转）。
    - 优化时需保持单位模长（归一化）。
- **典型应用**：姿态估计（IMU）、机器人控制、物理仿真（Mujoco、Isaac Gym）。
---

## 4.  旋转矩阵（Rotation Matrix）

- **维度**：9（3x3矩阵）
- **含义**：3D空间旋转的线性变换矩阵。
- **优点**：
    - 表达完整，无奇异。
    - 直接应用于点、向量变换。
    - 适用于正运动学、逆运动学。
- **缺点**：
    - 冗余（9个数表示3个自由度）
    - 优化难（需保持正交约束 $R^TR = I$）。
- **典型应用**：运动学建模、Jacobian计算、机械臂末端控制。
    

---

## 5. 6D旋转表示法（6D Rotation Representation）

- **维度**：6（2个3D向量）
- **含义**：取旋转矩阵的前两列，优化后通过Gram-Schmidt正交化得到正交旋转矩阵。
- **优点**：
    - 连续、无奇异、数值稳定。
    - 适合神经网络回归，无需归一化或单位模约束。
    - 比四元数训练更稳定（用于RL、VAE等）。
- **缺点**：
    - 插值稍复杂（需重建矩阵）。
- **典型应用**：深度学习（姿态回归、RL策略网络）、VMP、AMASS数据处理、轨迹生成。

## 6. 总结

| 方法                                        | 维度  | 是否唯一   | 是否存在奇异性         | 是否易于插值   | 是否适合优化        | 适用场景                  |
| ----------------------------------------- | --- | ------ | --------------- | -------- | ------------- | --------------------- |
| **欧拉角 (Euler Angles)**                    | 3   | 否（多解）  | 存在（Gimbal Lock） | 差        | 差（不适合梯度优化）    | 可视化，简易指令控制，低自由度场景     |
| **轴角 (Axis-Angle)**                       | 3   | 是      | 无               | 中等       | 中（不连续性问题）     | 轨迹规划，旋转差计算            |
| **四元数 (Quaternion)**                      | 4   | 否（双覆盖） | 无               | 好（SLERP） | 中（需归一化）       | 姿态插值，动力学仿真，SLERP      |
| **旋转矩阵 (Rotation Matrix)**                | 9   | 是      | 无               | 差（占内存）   | 差（约束难处理）      | 机器人正/逆运动学，Jacobian 计算 |
| **6 D 表示法 (6 D Rotation Representation)** | 6   | 是      | 无               | 好        | 好（无奇异性、连续、正交） | 神经网络，姿态回归，RL          |


| 应用领域            | 推荐方法         | 理由                    |
| --------------- | ------------ | --------------------- |
| **运动控制（IK/FK）** | 旋转矩阵、轴角      | 计算简便，Jacobian直接基于旋转矩阵 |
| **状态估计（IMU）**   | 四元数          | 无奇异，适合姿态滤波与积分         |
| **轨迹优化（MPC等）**  | 轴角、四元数（误差表示） | 轴角适合误差小，四元数适合全姿态      |
| **神经网络回归**      | 6D旋转表示法      | 连续、易优化、避免归一化          |
| **仿真/物理引擎**     | 四元数          | 高效、内存占用低、支持SLERP      |


# 6. 阻抗模型

机器人阻抗模型建模（Impedance Model Modeling）” 指的是用数学或物理模型描述机器人**在外力作用下的动态响应特性**。

 首先，从标准的笛卡尔阻抗模型出发，将机器人末端执行器（或身体某部分）在期望轨迹附近的受力关系写成 $$ F \;=\; K\big(x - x_{\text{des}}\big)\;+\;D\big(\dot x - \dot x_{\text{des}}\big)\;+\;M\big(\ddot x - \ddot x_{\text{des}}\big), $$
 
 - $x$是实际位置，$x_{\text{des}}$、$\dot x_{\text{des}}$、$\ddot x_{\text{des}}$是期望位置、速度、加速度；
 - $K,D,M$分别是等效刚度、阻尼、质量（惯量）系数；
 - $F$是末端的合力。
 
 在大多数接触操作是“缓慢/准静态”的前提下，可以忽略速度与加速度耦合，将模型简化为 $$ F \;\approx\; K\big(x - x_{\text{des}}\big). $$ 这一步的意义是：若动作不快、惯性与黏性效应不强，则“偏离期望位置的弹簧力”足以刻画交互。接着定义控制输入与环境力学量。控制侧提供两类命令：
 - 相对于机体坐标系给出的期望位置命令$x_{\text{cmd}}$与期望作用力命令$F_{\text{cmd}}$。
 - 环境带来外部扰动力$F_{\text{ext}}$，同时当末端与环境接触且施加$F_{\text{cmd}}$时，环境会产生反作用力$F_{\text{react}}$与之抗衡。

 于是末端“合力”可写为 $$ F \;=\; F_{\text{ext}} \;+\; \big(F_{\text{cmd}} - F_{\text{react}}\big). $$ 把它代入前述简化的阻抗关系，并把$x_{\text{des}}$记为当前希望让策略去跟踪的“目标位置”$x_{\text{target}}$，得到 ：
 $$ K\big(x - x_{\text{target}}\big) \;=\; F_{\text{ext}} + \big(F_{\text{cmd}} - F_{\text{react}}\big). $$ 在控制命令层面，我们希望“围绕$x_{\text{cmd}}$去工作”，因此把$x$理解为受力后的平衡解，并把右端项理解为对$x_{\text{cmd}}$的补偿，就有 $$ x_{\text{target}} \;=\; x_{\text{cmd}} \;+\; \frac{F_{\text{ext}} + \big(F_{\text{cmd}} - F_{\text{react}}\big)}{K}. $$ 它明确给出：目标位置相当于在纯位置命令$x_{\text{cmd}}$的基础上，把“外扰与力命令—环境反力”的净效应，通过“刚度$K$的倒数”转成一个**位移补偿量**。直观上，$K$越大，系统越“硬”，相同的净力只允许更小的位移妥协；$K$越小，系统更顺从，位移补偿更大。
 
 **由此一个统一的配方同时涵盖了常见的四类行为**：
 - 只给$x_{\text{cmd}}$就是位置控制；
 - 只给$F_{\text{cmd}}$就是力控制；
 - 给$x_{\text{cmd}}$同时受$F_{\text{ext}}$扰动就是顺应/阻抗控制；
 - 在切向跟踪$x_{\text{cmd}}$、法向施加$F_{\text{cmd}}$就是混合力—位控制。
 
上述讨论针对末端执行器。对于“机体/基座”的建模，关心的往往不是基座的绝对位置，而是其速度或姿态调节对整体稳定/顺应的作用。因此，把同样的阻抗思想应用到“速度通道”，把位置项去掉，仅保留阻尼环节，写成 $$ F_{\text{base}} \;=\; D\big(\dot x_{\text{base}} - \dot x_{\text{des,\,base}}\big) \;=\; D\big(v_{\text{base}} - v_{\text{des,\,base}}\big), $$ 其中$v_{\text{base}}$是实际基座速度，$v_{\text{des,\,base}}$是想要的目标基座速度。基座受到的净力同理可写为 $$ F_{\text{base}} \;=\; F_{\text{ext,\,base}} \;+\; \big(F_{\text{cmd,\,base}} - F_{\text{react,\,base}}\big). $$ 把它代入并解出$v_{\text{des,\,base}}$（即$v_{\text{target,\,base}}$），得到文中式(4)： $$ v_{\text{target,\,base}} \;=\; v_{\text{cmd,\,base}} \;+\; \frac{F_{\text{ext,\,base}} + \big(F_{\text{cmd,\,base}} - F_{\text{react,\,base}}\big)}{D}. $$ 这表明，基座速度命令同样可以按“净力/阻尼”的规则被补偿，以产生合适的顺应或抗扰。这一点在腿足/躯干被推挤、需要靠“身法”配合手部操作时尤其重要。

>为了完整性，作者还讨论了“多接触/多部位的力学耦合”。严格地讲，基座上的力可以通过刚体动力学和雅可比映射为末端的等效外力，反之亦然；在复杂情形下应做统一求解。但考虑到学习复杂度与工程可行性，**本文在训练时把“末端”和“基座”分开建模与补偿：末端按位置层的补偿，基座按速度层的补偿。**

这种分治已足以支撑展示的多种顺应行为与跨形态（四足/人形）场景。从控制到学习的衔接是这样的：高层在每个时刻发出$x_{\text{cmd}},F_{\text{cmd}}$（末端）与$v_{\text{cmd,\,base}},F_{\text{cmd,\,base}}$（基座），策略内部首先根据历史状态去“估计外力与反力的合力”，再用上面两条公式计算$x_{\text{target}}$与$v_{\text{target,\,base}}$，**最后把它们转化成关节空间的期望**，交给底层 PD 去跟踪。

强化学习阶段的奖励就围绕“目标位置/目标速度的跟踪误差”来设计，从而把这种力—位耦合行为学出来。这一建模的关键假设与影响也在文中点明。
- 第一，末端采用准静态近似，隐去$D,M$项，适合擦拭、拉拽等低速接触任务；若要处理高速/高频互动，需要把速度与加速度项显式纳入，或者提高控制/估计频率。
- 第二，反作用力$F_{\text{react}}$不单独建模，而是并入“可由策略从历史状态中估计”的合力项里；训练时通过丰富的力命令与外扰采样，让策略在大量情形中学会“应该补多少”
- 第三，末端与基座目前按“并行通道”处理，未在单一优化中统一耦合，这留作未来工作以覆盖更复杂的全身多点受力协同。


