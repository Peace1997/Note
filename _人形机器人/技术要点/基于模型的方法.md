

AMP：通过优化机体质心加速度，使足底不翻，从而实现平衡等任务
MPC：通过优化足底接触力，进而改变机体质心位置，使质心处于可控范围，去实现平衡等任务，

人形机器人想要精度需要位置控制模式，想要更受控安全一些需要用力矩模式（PVT），但是存在稳态误差，精度不会特别高。



通过**MPC 规划足底接触力**，再通过**雅可比矩阵计算关节力矩**，可实现机器人对目标速度的跟踪。


---

## 1. 机器人建模

在MPC控制框架下，需要建立机器人的**运动学模型、动力学模型**，并结合**约束条件**来构建优化问题。

### 1.1 运动学建模

机器人足端位置和速度可通过**雅可比矩阵（Jacobian Matrix）** 表示：

$$\mathbf{p}_{foot} = f(\mathbf{q})
$$
$$  \dot{\mathbf{p}}_{foot} = \frac{d}{dt} f(\mathbf{q}) =  \frac{\partial f(\mathbf{q})}{\partial \mathbf{q}} \cdot \frac{d \mathbf{q}}{d t}=J_f(\mathbf{q}) \dot{\mathbf{q}}
$$
其中：

- $\mathbf{q} \in \mathbb{R}^6$ 是关节角度向量；
- $\mathbf{p}_{foot} \in \mathbb{R}^3$ 是足端位置, 可通过正运动学求解；
- $J_f \in \mathbb{R}^{3 \times 6}$ 是足端的线速度雅可比矩阵，如果考虑足端的角速度，则需要扩展雅可比矩阵，使其包括旋转部分；
- $\dot{\mathbf{q}}$ 是关节角速度。

**Python 代码（使用 Pinocchio 计算雅可比矩阵）：**

```python
import pinocchio as pin
import numpy as np

# 载入机器人模型
robot = pin.RobotWrapper.BuildFromURDF("robot.urdf", package_dirs=["./"])

# 计算足端雅可比矩阵
q = np.zeros(robot.nq)  # 机器人当前关节角度
J_foot = robot.computeFrameJacobian(q, robot.model.getFrameId("foot_link"), pin.LOCAL_WORLD_ALIGNED)
```

---

### 1.2 动力学建模
机器人完整的动力学方程是基于**拉格朗日动力学（Lagrangian Dynamics）** 或**牛顿-欧拉方法（Newton-Euler Method）** 推导出来的。用于将足端力映射到关节力矩关节空间形式（Joint-Space Formulation） 表示如下：
$$\mathbf{M(q)} \ddot{\mathbf{q}} + \mathbf{C(q, \dot{q})} \dot{\mathbf{q}} + \mathbf{G(q)} = \mathbf{B} \boldsymbol{\tau} + J_f^T \mathbf{F_f}$$

其中：

- $\mathbf{M(q)} \in \mathbb{R}^{6 \times 6}$ 是惯性矩阵，描述机器人在不同关节角度 $\mathbf{q}$处的**质量**和**惯性**特性，用于描述关节之间的耦合关系，即一个关节的加速度如何影响其他关节的运动。
- $\mathbf{C(q, \dot{q})} \dot{\mathbf{q}}$ 是科氏力和离心力项，计算机器人运动过程中由于关节间速度耦合产生的力矩；
- $\mathbf{G(q)}$ 是重力项，由于重力作用，机器人需要施加的平衡力矩；
- $\mathbf{B}$ 是关节驱动力矩映射矩阵，用于将足端力映射到关节力矩；
- $\boldsymbol{\tau}$ 是关节力矩，这个力矩由 MPC 计算得到；
- $\mathbf{F_f} \in \mathbb{R}^3$ 是足底接触力。 $J_f^T$ 是机器人足端的雅可比矩阵的转置，$J_f^T \mathbf{F_f}$ 机器人足端受外力的力矩。


**Python 代码（计算动力学参数）：**

```python
# 计算动力学参数
M = pin.crba(robot.model, robot.data, q)  # 计算惯性矩阵
C = pin.computeCoriolisMatrix(robot.model, robot.data, q, np.zeros(robot.nv))
G = pin.computeGeneralizedGravity(robot.model, robot.data, q)
```

---

## 2. MPC 规划足底接触力

在 MPC 控制框架下，我们希望找到一个最优的足底接触力 $f\mathbf{F_f}$，使机器人跟踪目标速度 $\mathbf{v}_{des}$。

### 2.1 状态空间模型

定义状态向量：
$$\mathbf{x} = \begin{bmatrix} \mathbf{q} \\ \dot{\mathbf{q}} \end{bmatrix}, \quad \mathbf{u} = \mathbf{F_f}$$
离散化后：
$$\mathbf{x}_{k+1} = A \mathbf{x}_k + B \mathbf{u}_k$$
其中：
- A, B 由动力学模型线性化后离散化得到。

**Python 代码（离散化状态方程）：**

```python
dt = 0.01  # 离散化时间步长
A = np.eye(12) + dt * np.block([[np.zeros((6,6)), np.eye(6)], [np.zeros((6,6)), np.linalg.inv(M) @ -C]])
B = dt * np.block([[np.zeros((6,3))], [np.linalg.inv(M) @ J_foot.T]])
```

---

### 2.2 目标函数

$$J = \sum_{k=0}^{N} \left( \|\mathbf{v}_k - \mathbf{v}_{des}\|^2_Q + \|\mathbf{F}_{f,k}\|^2_R \right)$$

- Q 权重控制速度误差；
- R 权重控制接触力的大小。

**Python 代码（目标函数）：**

```python
import cvxpy as cp

N = 10  # 预测步长
x = cp.Variable((12, N+1))
u = cp.Variable((3, N))

Q = np.diag([1, 1, 1, 0, 0, 0, 10, 10, 10, 0, 0, 0])  # 速度误差权重
R = np.diag([0.1, 0.1, 0.1])  # 力控制权重
v_des = np.array([0.2, 0, 0])  # 目标速度

cost = 0
for k in range(N):
    cost += cp.quad_form(x[6:9, k] - v_des, Q) + cp.quad_form(u[:, k], R)

objective = cp.Minimize(cost)
```

---

### **2.3 约束条件**

1. **动力学约束**

$$\mathbf{x}_{k+1} = A \mathbf{x}_k + B \mathbf{u}_k$$

2. **摩擦约束**

$$F_{fz} > 0, \quad \sqrt{F_{fx}^2 + F_{fy}^2} \leq \mu F_{fz}$$

3. **关节限制**

$$\mathbf{q}_{min} \leq \mathbf{q} \leq \mathbf{q}_{max}$$

**Python 代码（添加约束）：**

```python
constraints = []
for k in range(N):
    constraints.append(x[:, k+1] == A @ x[:, k] + B @ u[:, k])
    constraints.append(u[2, k] >= 0)  # 足底力必须向上
    constraints.append(cp.norm(u[:2, k]) <= 0.7 * u[2, k])  # 摩擦锥约束
```

---

## **3. 控制执行**

求解优化问题并将足底接触力转换为关节力矩：

$$\boldsymbol{\tau} = J_f^T \mathbf{F_f}$$

**Python 代码（求解优化问题并发送控制指令）：**

```python
prob = cp.Problem(objective, constraints)
prob.solve()

F_f_opt = u[:, 0].value  # 取第一个步长的接触力
tau = J_foot.T @ F_f_opt  # 计算关节力矩

send_to_robot(tau)  # 发送至机器人控制器
```

---

## **4. 结论**

通过**MPC 规划足底接触力**，再通过**雅可比矩阵计算关节力矩**，可实现机器人对目标速度的跟踪。该方法在物理机器人上部署时，需要调整 QP 求解器（如 OSQP）以提高实时性。

如果你的机器人有具体的控制接口（如 CAN 总线或 ROS 控制器），我可以提供更详细的代码示例来适配硬件。