# 动态规划

重叠子问题、最优子结构、状态转移方程就是动态规划三要素。

动态规划中每一个状态一定是由上一个状态推导出来的，而贪心是局部直接选最优的。

**要符合「最优子结构」，子问题间必须互相独立**

类似于二叉树中子问题的分解



## 一、 解题步骤


- 明确**状态**（状态转移过程中变化的量 ）
  > dp数组中，状态就是索引；递归函数中，状态是参数 

- 明确**选择**（状态转移过程中可供选择的量）

- 明确 DP  函数// 数组的定义 （用于 状态转移）

- 明确 base case（初始值  //  终止条件（递归））

```python
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
	# base case 设置终止条件
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0] = base
# 进行穷举和状态转移
for 状态1 in 状态1的所有取值:
	for 状态2 in 状态2的所有取值:
        for ...
        	dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

## 二、动态规划问题的本质

1. 如何穷尽：

   写出状态转移方程，**暴力穷举**所有可行解

2. 聪明的穷举：

   - 用备忘录消除重叠子问题（记忆），写出自顶向下解法 
   - 进一步，可以写出自底向上的迭代解法
   - 再进一步，优化空间复杂度

## 三、举例说明
对于 1-4 题，通常仅设计一个字符串或数组，**一维 dp**  数组就可以表示
```python
length = len(arr)

# 求最大值用0，求最小值用float("inf")
dp = [0//float("inf)]*length  

for i in range(1,length):
	for j in range(i):
		dp[i] = 最值(dp[i],dp[j]+.....)
```

对于 5-6 题，涉及两个字符串/数组的子序列，一个维度的 `dp` 数组已经不能满足要求，此时需要**二维 dp**数组来表示
```python
row,col  = len(arr),len(arr[0])  //  len1,len2 =len(text1),len(text2)

dp = [ []*col for i in range(row) ]  # 如何为了避免出界，可以增加一行一列

for i in range(row):
	for j in range(col):
		if arr[i] ==  arr[j]:
			dp[i][j] = dp[i][j] + ...
		else:
			dp[i][j] = 最值(...)
```



### 1. 斐波那契数列

通过斐波那契数列可以比较清晰的看出状态转移过程和重叠子问题，对于最优子结构，因为没有涉及求最值，因此体现的并不是很明显。

```python
# 最简单形式。自顶向下，无备忘录 —— 递归
# 状态：n
# 选择：-1、-2
# 状态转移：DP(n) = DP(n-1) + DP(n-2)
# base case: DP(0)=0 DP(1)=1

class Solution:
    def fib(self, n: int) -> int:
        if n<2:return n
        result = self.fib(n-1)+self.fib(n-2)
        return result
    
# 消除重叠子问题，解决重复计算。自顶向下，有备忘录（剪枝） —— 递归
# 状态、选择、状态转移、base case不变
# 通过外部变量 self.res 记录之前已经计算过的DP[n]的值
class Solution:
    def fib(self, n: int) -> int:
        self.res = {}
        def traverse(n):
            if n<2:return n
            if n in self.res: return self.res[n]
            result = (traverse(n-1)+ traverse(n-2))%1000000007
            self.res[n] = result  
            return result
        return traverse(n)
    
# 自底向上，无递归
# 状态、选择、状态转移、base case不变
# 取消递归的方式，通过遍历来完成
class Solution:
    def fib(self, n: int) -> int:
        if n<2:return n
        DP = {}
        DP[0]=0
        DP[1]=1
        for i in range(2,n+1):
            DP[i] = (DP[i-1] + DP[i-2])%1000000007
        return DP[n]
# 自底向上，简化版 ;降低空间复杂度
class Solution:
    def fib(self, n: int) -> int:
        if n<2:return n
        a,b= 0,1
        for i in range(2,n+1):
            c = (a+b)%1000000007
            a,b = b,c
        return c
```

### 2. 凑零钱

https://leetcode.cn/problems/coin-change/

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

```python
# 自顶向下递归
# base case：dp[0] = 0; if amount<0 dp[amount]=-1
# 状态：当前金额大小，希望大小从 amount  -> 0
# 选择：coins中不同金额大小coin
# DP：dp[amount] = min(min_number,dp(amount - coin))
# 缺点：通过递归树可知，存在重复计算

class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount<0:return -1
        if amount==0:return 0
        min_number = float("inf")
        for i in coins:
            result = self.coinChange(coins,amount-i)
            if result != -1:
                min_number = min(min_number,result+1)
        return min_number if min_number < float("inf") else -1
            

# 消除重叠子问题，消除重复，自顶向下递归
# 缺点：这两种方法都超时
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        self.res = {}
        def traverse(coins,amount):
            if amount<0:return -1
            if amount==0:return 0
            min_number = float("inf")
            for i in coins:
                if amount in self.res:
                    if self.res[amount]!=-1:
                        min_number = min(min_number,self.res[amount])
                else:
                    result = traverse(coins,amount-i)
                    if result != -1:
                        min_number = min(min_number,result+1)
            self.res[amount] = min_number if min_number < float("inf") else -1
            return self.res[amount]
        return traverse(coins,amount)
 
# 自底部向上迭代计算
# 状态选择与上方相同
# 状态转移过程： if n==0 : dp[0]=0 、 if amount<0 dp[amount]=-1、  else ： dp[amount] = min(dp[amount],dp[amount - coin])
# 缺点：存在一些不必要的计算，某些dp可以不用计算
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount==0: return 0
        dp = {}            
        dp[0]=0
        for i in range(1,amount+1):
            dp[i] = float("inf") # 注意在这里要对每个dp[i] 初始化，便于下面筛选。
            for j in coins:
                if i-j>=0:
                    dp[i] = min(dp[i],dp[i-j]+1)
        return dp[amount] if dp[i]<float("inf") else -1
    
# 自底向上迭代计算
# 在上面基础上调换了两个for循环位置，若for i in range(coin,amount+1) 在前就会有很多异常值需要处理（if i-j>=0），修改两个for 循环位置，并对第二个for循环略微修改，就可以避免一些异常值的计算。
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount==0: return 0
        dp = [float('inf')] * (amount + 1)         
        dp[0]=0
        for coin in coins:
            for i in range(coin,amount+1): 
                dp[i] = min(dp[i],dp[i-coin]+1)
        return dp[amount] if dp[amount]<float("inf") else -1

            
```



### 3. 最长递增子序列

https://leetcode.cn/problems/longest-increasing-subsequence/
```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

```python
# 状态：以nums[i]这个数结尾的最长递增子序列长度
# 选择：该状态之前的所有状态的
# DP：dp[i] = max(dp[:i-1]+1,dp[i])；dp数组用于记录状态递增序列的长度
# dp[0] = 0
# 时间复杂度O(N^2)
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        length = len(nums)
        if length == 0: return 0
        dp =[1]*length
        for i in range(1,length):
            for j in range(i):#寻找之前比当前位置值小且长度最长的状态
                if nums[j]<nums[i]:
                    dp[i] = max(dp[j]+1,dp[i])
        return max(dp)


class Solution:

    def lengthOfLIS(self, nums) -> int:

        # 将原状态中，dp[i]表示当前位置i的最长递增子序列的长度，
        # 现在dp[i]表示，长度为i+1的所有子序列中的结尾最小的值
        # res 用于记录当前dp数组位置，也就是最长递增子序列的长度，因为是从0开始，所以每插入一个元素就往后延一个，
        # 这样做1是方便记录长度，2是有利于在二分查找定位时，能够与当前DP数组插入的最后一个元素进行一次比较，若不对比则无法比较将较小的替换

        dp,res = [0]*len(nums),0
        for num in nums:
            i,j = 0,res
            while i<j:
                m = (i+j)//2
                if num>nums[m]:
                    i=m+1
                else: j=m
            dp[i] = num
            if j==res:
                res+=1
        return res
```

### 4. 最大子数组和

https://leetcode.cn/problems/maximum-subarray/
```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

```python
# 状态：当前位置DP[i]最大的子数之和
# 选择：当前位置数据nums[i]、上一个位置最大数组之和DP[i-1] + 当前位置数据nums[i]  
# DP: DP = max(nums[i],DP[i-1]+nums[i])
# DP[0] = nums[0]

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if len(nums)==1:return nums[0]
        length  = len(nums)
        dp =[0]*length
        dp[0]=nums[0]
        for i in range(1,length):
            dp[i] = max(nums[i],dp[i-1]+nums[i])
        return max(dp)
```

### 5. 最长公共子序列

https://leetcode.cn/problems/longest-common-subsequence/
```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```


```python

# 状态：当前最长公共子序列长度 dp[i][j]
# 选择：序列下一个位置
# DP： DP[i][j] = max(DP[i+1][j+1],DP[i][j+1]，DP[i+1][j])
# Base case : 任意i、j达到其子序列最长返回 0

class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        len1,len2 = len(text1),len(text2)
        def traverse(i,j):
            if i==len1 or j==len2: return 0
            if text1[i] == text2[j]:
                return 1+traverse(i+1,j+1)
            else:
                return max(traverse(i,j+1),traverse(i+1,j))
        return traverse(0,0)

# 加入备忘录
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        len1,len2 = len(text1),len(text2)
        dp = [[-1]*len2 for _ in range(len1)]
        def traverse(i,j):
            if i==len1 or j==len2: return 0
            if dp[i][j]!=-1: return dp[i][j]
            if text1[i] == text2[j]:
                dp[i][j] =  1+traverse(i+1,j+1)
            else:
                dp[i][j] =  max(traverse(i,j+1),traverse(i+1,j))
            return dp[i][j]
        return traverse(0,0)


# 动态规划，无递归
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        len1,len2 = len(text1),len(text2)
        dp = [[0]*len2 for _ in range(len1)]
        for i in range(len1):
            for j in range(len2):
                if text1[i] == text2[j]:
                    if i-1>=0 and j-1>=0:
                        dp[i][j] = dp[i-1][j-1]+1
                    else:
                        dp[i][j] = 1
                else:
                    dp[i][j] = max(dp[max(i-1,0)][j],dp[i][max(j-1,0)])

        return dp[i][j]

# DP数组额外增加一行一列，减少判断条件
# 判断时，我们假设增加的行列是在上方和左边的，而实际增加的行列是增加在最下方和右边的
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        len1,len2 = len(text1),len(text2)
        dp = [[0]*(len2+1) for _ in range(len1+1)]
        for i in range(len1):
            for j in range(len2):
                if text1[i] == text2[j]:
                    dp[i][j] = dp[i-1][j-1]+1
                else:
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])
        return dp[i][j]
```






### 5. 最小路径之和

https://leetcode.cn/problems/0i0mDW/
```python
# 状态：当前所在位置DP[i][j]的路径之和
# 选择：向右或向下
# DP：DP[i][j] = grid[i][j] + min[dp[i-1][j],dp[i][j-1]]
# DP[0][0] = grid[0][0]
# 难点：如何避免出界，额外增加一行、一列
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m,n = len(grid),len(grid[0])
        dp=[[float("inf")]*(n+1) for _ in range(m+1)]
        dp[0][0]=grid[0][0]
        
        for i in range(m):
            for j in range(n):
                if i==0 and j==0:continue
                dp[i][j] = grid[i][j]+min(dp[i-1][j],dp[i][j-1])
        return dp[m-1][n-1]


DP[i][j] = Data[i][j] + min(DP[i+1][j],DP[i][j-1],DP[i-1][j],DP[i][j+1])

```






- 确定DP数组以及下标的含义
- 确定递推公式
- DP数组如何进行初始化
- 确定遍历顺序
- 举例推倒 DP 数组


