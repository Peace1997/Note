### 框架

```python
class TreeNode: 
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
        
# 基本框架：
class Solution:
  	def traverse(root: TreeNode):
    		# 前序位置
    		traverse(root.left);
    		# 中序位置
    		traverse(root.right);
    		# 后序位置
  	
```



## 解题模式(递归解法)



1、**是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「**遍历**」 的思维模式。 ——— 对应着回溯算法框架

> 在这里可以将`traverse`理解为在二叉树上游走的指针。

**2、是否可以定义一个递归函数（明确该函数要完成什么任务），通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「**分解问题**」的思维模式。 ——— 动态规划

> 要先了解递归函数要实现的功能，先不用细究该函数，把该函数看成一个整体去考虑怎么实现整体功能。

==无论使用哪一种思维模式，你都要明白二叉树的**每一个节点需要做什么**，需要在**什么时候（前中后序）做**。其他节点不用操心，递归函数会帮你在所有节点执行相同的操作。==



> - 节点需要做什么，在什么时候做他们两个是绑定的。
> - 遍历问题通常返回 None；分解问题的返回值与自己设定的函数有关

**二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作**。





## 前、中、后序位置

**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

**二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作**。

### 前序位置

- 前序位置的代码在**刚刚进入一个二叉树节点的时候执行**；
- 前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。
- 前序位置的**代码执行是自顶向下的**
- **前序位置的代码只能从函数参数中获取父节点传递来的数据**

### 中序位置

- 中序位置的代码**在一个二叉树节点左子树都遍历完，即将开始遍历右子树**的时候执行。
- 中序位置主要用在 BST （二叉搜索树）场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。
- 多叉树一般不会有中序位置

### 后序位置

- 后序位置的代码在**将要离开一个二叉树节点的时候执行**；
- 而后序位置的**代码执行是自底向上的**：
- **后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。
- 一般使用后序遍历就是属于**分解**的问题

<img src="img/BinaryTree" alt="img" style="zoom: 25%;" />





### 问题讨论

1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

2、如何打印出每个节点的左右子树各有多少节点？

这两个问题的根本区别在于：一个节点在第几层，你从根节点遍历过来的过程就能顺带记录；而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚。**只有后序位置才能通过返回值获取子树的信息**。

**一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。



## 两种模式举例： 

### 先序遍历

```Python
#第一种解题模式：遍历
#自顶向下，按照 根-左-右 的顺序遍历各个节点
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def traverse(root: TreeNode):
            if not root:
                return None
            res.append(root.val)
            traverse(root.left)
            traverse(root.right)
        res= []
        traverse(root)
        return res

    

# 第二种接题方法：分解
class Solution2:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if not root:
            return []
        res.append(root.val)
        res += self.preorderTraversal(root.left)
        res += self.preorderTraversal(root.right)
        return res
```

对于前序遍历，根节点位于第一位，然后接着左子树的遍历结果，最后接着右子树的前序遍历结果。通过**分解**的思路：**一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果**

中序遍历可以分解为：一棵二叉树的中序遍历结果 = 左子树的前序遍历结果 +  根节点 + 右子树的前序遍历结果

后续遍历可以分解为：一棵二叉树的后序遍历结果 = 左子树的前序遍历结果 +  右子树的前序遍历结果  +  根节点 

![300](img/tree1.png)




### 二叉树深度

```python
# 第一种解题模式: 对二叉树完成一次遍历即可得到最后的结果
# 通过traverse函数遍历每个节点，并记录它的深度信息，遍历完所有节点，找到最大的什么，所以既要有记录节点的深度的变量，也要有记录整个二叉树深度的变量
# 每个节点应该做什么：要记录自己的深度的同时也要记录此时最大的深度
# 每个节点需要在什么时候做：
# 	- 在先序位置做时，进入该节点时，要对深度进行一个记录，但是
#	- 在后序位置做时，离开该节点时，要对深度-1

class Solution:
    def maxDepth(self,root):
        def traverse(root:TreeNode):
            if not root: return
            #前序位置
            self.depth+=1 
            if not (root.left and root.right):
                self.res = max(self.res,self.depth)
            traverse(root.left)
            traverse(root.right)
            #后序位置
            self.depth-=1

        self.depth =0
        self.res = 0
        traverse(root)
        return self.res



# 第二种解题模式：通过子问题（左右子树）的结果推导出原问题的结果
# 子问题应该完成什么任务：判断左右子树哪个更深
# 子问题返回值：返回左右子树中较深的深度值
# 每个节点应该完成什么任务：选择更深的子树然后算上自己节点深度，即 max(left_max,right_max)+1
# 该节点需要在什么时候做：需要有了左右节点深度后才能做，所以要在后序位置。
class Solution2:
    def maxDepth(self,root:TreeNode):
        if not root: return 0
        left_max = self.maxDepth(root.left)
        right_max = self.maxDepth(root.right)
        return max(left_max,right_max)+1

```

### 二叉树反转

```python
# https://leetcode.cn/problems/invert-binary-tree/
    
# 遍历的方法
# 通过一个traverse函数遍历每个节点，让每个节点的左右子树节点颠倒过来
# 单独抽出一个节点做什么：让它自己的左右子节点交换一下，在进入该节点
# 该节点需要在什么时候做呢：前、后序位置都可以；
# 	- 在前序位置做时，你在进入该节点时，左右子树还没开始交换，就将左右子树进行交换
# 	- 在后序位置做时，左右子树都交换了，你在离开节点时，再将左右子树进行交换
# 	- 在中序位置做时，进入节点时，什么也不做，在进入右子树前，将左右子树进行交换，此时之前的右子树又变成了左子树，新进入的右子树还是刚才的左子树，则右子树存在子节点则无法进行交换，且刚才交换过的左子树又要被交换回去。

class Solution1:
    def invertTree(self, root: TreeNode) -> TreeNode:
        
        def traverse(root:TreeNoede):
            # 前序位置
            root.left,root.right = root.right,root.left
            traverse(root.left)
            traverse(root.right)
        traverse(root)
        return root

class Solution2:
    def invertTree(self, root: TreeNode) -> TreeNode:
        
        def traverse(root:TreeNoede):

            traverse(root.left)
            traverse(root.right)
            # 后序位置
            root.left,root.right = root.right,root.left
        traverse(root)
        return root       
        
        
# 分解的方法
# 每个子函数应该做什么：根节点完成左右子树的交换
# 每个子函数应该返回什么：返回已经完成左右子树交换的根节点
# 每个节点应该做什么：完成左右子树的交换，即root.left,root.right = right,left
# 需要在什么时候做：因为要完成左右子树的交换后，再将左右子数据交换，所以要在后序位置完成左右子树交换
class Solution3:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root: return root
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left,root.right = right,left
        return root

```



### 填充节点的右侧指针

二叉树变成三叉树，将每个节点的next节点指向相邻节点，难点在于不同的父节点之间的相互连接（即下图中5、6节点的连接），因此这里进行一个变换，将每行中相邻的两个节点连接在一起算作一个组合节点，把一颗二叉树抽象成一个三叉树。

通过**遍历**的思想，依次遍历每个组合节点，每个节点要做的就是将组合节点的两个节点连接起来即可，然后在依次遍历其他三个组合节点。

```python
# https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/
# 遍历的思想
# 每个节点在什么时候开始做： 前、中、后序位置都可以，组合节点中两个节点相互连接在什么时候都可以进行，不会对其造成影响。
# 单独一个节点要做什么: 将组合节点中的左节点指向右节点
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        def traverse(node1,node2):
            if not node1: return
            
            node1.next = node2
            traverse(node1.left,node1.right)
            traverse(node2.left,node2.right)
            traverse(node1.right,node2.left)

            
        if not root: return
        traverse(root.left,root.right)
        return root

```



![img](https://labuladong.github.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%97/1.png)

<img src="https://labuladong.github.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%97/3.png" alt="img" style="zoom:50%;" />



### 二叉树展开为链表

若采用遍历的方法，仅需要在每个节点在前序位置，不断把当前`root.value`作为新节点插入到单链表即可，因为题目要求需要在一个函数内完成且不需要返回值，因此遍历的思想不是很适用，

```python
# https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/
# 对于每个子函数（flatten）应该完成什么任务：将二叉树展平
# 每个节点应该完成什么任务：将左子树展平、将右子树展平，然后将展平的右子树拼在左子树下面
# 每个节点在什么时候进行：因为需要左右子树都展平后在拼接，因此需要在后序位置进行

class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root: return 
        self.flatten(root.left)
        self.flatten(root.right)

        res = root.right
        root.right,root.left = root.left,None
        while root.right:
            root = root.right
        root.right = res
```



![img](https://labuladong.github.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%97/2.jpeg)


二叉数可以应用到动态规划、回溯算法、分治算法、图论算法、排序算法中去。
