## 快速排序

**快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历**
快速排序：先把一个元素排好序（p）--> （这也就是为什么需要前序遍历的原因），在递归的再把剩下的元素排好序，

**左边元素为基准为什么要从右边开始搜索？**
因为是最左边元素为基准，所以要从右边开始搜索。如果先从左边开始搜索，则右边搜索时可能无法找到比基准小的元素，而从右边开始搜索时，左边搜索时即使找不到比基准大的也没有关系，即确定这些元素都比基准元素小，可以直接确定分割点。

[参考](https://segmentfault.com/a/1190000015396497 )



```python
# 基于二叉树的思维框架：
####################################################### 版本1
def quicksort(nums,left,right):
    #二叉树前序遍历框架 
    if left>=right: return 
    p = partation(nums,left,right)    # 找分割点p
    quick_sort(nums,left,p-1)
    quick_sort(nums,p+1,right)
    
def partation(nums,left,right):
    i,j = left,right
    while i<j:		
        while nums[j]>nums[left] and i<j:j-=1
        while nums[i]<=nums[left] and i<j:i+=1
        nums[i],nums[j]=nums[j],nums[i]
    nums[i],nums[left] = nums[left],nums[i]
    return i

###################################################### 版本2 

# 左边为基准
def quicksort(nums,left,right):
    if left>=right:
        return
    i,j = left,right
    while i<j:
        while i<j and nums[j]>=nums[left]:j-=1
        while i<j and nums[i]<=nums[left]:i+=1
        nums[i],nums[j] = nums[j],nums[i]
    nums[left],nums[i]= nums[i],nums[left]

    quicksort(nums,left,i-1)
    quicksort(nums,i+1,right)


#  右边为基准
def quicksort(nums,left,right):
    if left>=right:
        return
    i,j = left,right
    while i<j:
		while i<j and nums[i]<nums[right]:i+=1
		while i<j and nums[j]>nums[right]:j-=1
		nums[i],nums[j] = nums[j],nums[i]
	nums[j],nums[right] = nums[right],nums[j]

    quicksort(nums,left,i-1)
    quicksort(nums,i+1,right)
    
#前两个版本，均超时，超时原因是无法很好处理顺序排列，这是因为顺序排序基准设置在了最左边，无法分段排序
#所以随机采取一个值和最左边基准元素进行交换，其他保持不变
###################################################### 版本3

def quick_sort(nums,left,right):
    if left>=right: return 
    p = partation(nums,left,right)
    quick_sort(nums,left,p-1)
    quick_sort(nums,p+1,right)
def partation(nums,left,right):
    idx = random.randint(left, right)#生成一个随机数
    nums[left],  nums[idx] =  nums[idx],  nums[left] #修改基准
    i,j = left,right
    while i<j:
        while nums[j]>=nums[left] and i<j:j-=1
        while nums[i]<=nums[left] and i<j:i+=1
        nums[i],nums[j]=nums[j],nums[i]
    nums[i],nums[left] = nums[left],nums[i]
    return i
```


## 归并排序
归并排序（分治）：先把数组左半边排好序，再把数组的右边排好序----> (后序遍历的原因)，最后在把两个子问题的结果合并。

```python
def sort(nums, left, right):
    mid = (left + right) / 2
    # 排序 nums[left..mid]
    sort(nums, left, mid)
    # 排序 nums[mid+1..hi]
    sort(nums, mid + 1, right)

    # 后序位置 
    # 合并 nums[lo..mid] 和 nums[mid+1..hi]
    merge(nums, left, mid, right)
   
```







## 层次遍历：

```python
# Definition for a binary tree node.
# 输入：root = [3,9,20,null,null,15,7]
# 输出：[[3],[9,20],[15,7]]

# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        queue = [root]
        res = []
        while queue:
            res.append([i.val for i in queue])
            for _ in range(len(queue)):
                node = queue.pop(0)
                if node.left:queue.append(node.left)
                if node.right:queue.append(node.right)
        return res
```

