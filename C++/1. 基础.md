
# 一、综合问题

## STL
 standard template library，其包含有大量的模板类和模板函数，是一些容器、算法和其他一些组件的集合，是一些容器、算法和其他一些组件的集合，STL 基本上达到了各种存储方法和相关算法的高度优化。

## Python & C++

*Python 与 C++语言特性*

Python 是脚本语言，脚本语言不需要编译，直接解释执行，由解释器进行解释。程序代码脚本语言可以直接执行，因此只需要编写-执行即可。 Python更加灵活
C++ 是编译型语言，需要编译成二进制代码，以可执行文件执行，需要经过编写-编译-汇编-链接-执行。C++ 逻辑更加清晰

*为什么要用 Python 而不用 C++*

- 首先ROS本身对Python有非常好的支持
- 主要从事强化学习的研究，通过 Pytorch 进行训练，使用 Python 语言更加统一，方便数据转换，直接获取机器人状态、激光雷达信息后，直接转成 Tensor 类型，传给神经网络进行训练
- Python 修改代码后不需要重新编译，编写执行即可，可以更关注高层的设计


- 不需要重新编译；C++需要借助 catkin 和 ROS 的编译系统，每次对程序代码进行改动，都需要使用 catkin_make 进行重新编译。
- 在C++中很多情况下需要显示的指定，例如C++需要现实的创建一个节点句柄用来创建话题、服务和动作，而Python则不需要显示创建节点句柄，因为ROS的Python接口可以隐式的实现。

*为什么要用 C++ 不用 Python？*

- 如果用户想在每秒帧数高、延迟低的要求下在纯粹的C++游戏引擎中进行强化学习研究，对于这种环境而言，使用纯粹的C ++库比Python库要适合得多。
- 由于全局解释器锁（GIL），Python 一次无法运行多个系统线程。多重处理是一种替代方法，但扩展性欠佳，并存在诸多缺点。C++没有这样的约束或限制，而且它的线种易于使用和创建。
- C++执行速度快、可移植性强、与硬件和其他软件系统的接口简单


*C++如何调用 Pytorch 训练好的模型*

用 Pytroch 进行训练，C++执行测试。
Pytorch搭建神经网络简单，而且反向传播梯度计算， 优化器梯度下降更新参数，都已经封装好了，包括各种激活函数等，训练方便快捷，而且还有可视化软件tensorboard、wandb可以方便的进行可视化展示，矢量化环境进行并行训练。
将训练好的模型保存为pt文件，可以通过调用 trace 函数，可以将 pt 文件转换成序列化文件，供C++调用，tensorflow可以直接保存为pd二进制文件。
通过C++搭建一个前向神经网络，此时已经不需要进行反向传播，而且一般全连接层可以满足大部分的需求，0.几毫米即可完成一次前向传播计算。

*C++和 C 语言？*
- C语言是面向过程的编程，C++是面向对象（类和继承）的编程，而且能够更方便的定义数据结构的属性，用到这些数据结构时，把他们当作“黑匣子”使用。


*什么是抽象？*
有选择地忽略；编程就是通过建立抽象来忽略我们此刻并不重视的因素。

# 二、 C++ 与 ROS

C++工程代码通常分为两个部分：
- 用于实现具体算法
- 用于进行 ROS 接口封装（数据的输入输出、以及算法的调用）


*g++编译过程:*

- 预处理：`test.cpp`  $\rightarrow$ `test.i`
- 编译： `test.i` $\rightarrow$ `test.s`
- 汇编：`test.s` $\rightarrow$ `test.o`
- 连接：`test.o` + `libxx.o` $\rightarrow$ `test`

当程序涉及多个 C++文件和外部依赖时，逐一输入 g++命令将很不方便，所以通常使用 **makefile**文件来编写编译脚本，使用 **make** 命令来进行编译，编译完成后可以调用 make clean 命令清除这些中间文件。

当程序有众多依赖和关联的时候，如果全部手动维护依赖关系是很麻烦的，**Cmake** 可以自动处理程序之间的关系，并产生相应的 makefile 文件，然后调用 make 就能轻松编译了。

> 使用CMake，需要新建一个MakeLists.txt文件，编写它需要遵循Cmkae预压。


*ROS 处理流程：*
系统按话题传递消息数据，系统通过回调函数处理话题消息。

> 回调函数：


### 1. 使用 catkin 编译 C++

**package. xml**
用于声明项目的各类依赖

**CMakeLists. txt**
ROS 编译系统需要 CMakeLists. txt 来告诉系统编译哪些文件，改文件存在于 src 文件下所在的各个目录（package. xml 文件所在的目录），注意与 catkin 工作区根目录下的 CMakeLists. txt 搞混。

**catkin_make**

编译 ROS 节点程序需要在 catkin 工作区(catkin_workspace)根目录下调用 catkin_make，这一操作会编译所有的节点并保证所有依赖是最新的。

```c
catkin_workspace/
	src/
		CMakeLists.txt
		package_1/
			CmakeLists.txt
			package.xml
		package_2/
			CmakeLists.txt
			package.xml
	build/
	devel/
```

### 2. 话题、服务、动作

话题、服务、动作是ROS节点通信的三种通信方式。

**话题**：是一种发布/订阅通信机制。话题发布者向多个订阅者进行广播，但通信是单向的。
**服务**：是同步的跨进程函数调用；服务器端定义一个回调函数来处理服务请求，并声明这个服务，客户端向服务器发送请求并获得响应，但缺乏关于进度的信息。服务适合哪些只需要偶尔去做，并且会在有限时间按内完成的任务。

>Topic 发布一个消息后，就直接去执行后面的程序；而Service 调用一个服务，会一直等待结果

**动作**：是异步的，与服务类似，动作客户端向动作服务器发送请求以实现某些目标并获得结果。与服务不同，在执行动作时，动作服务器会向动作客户端发送进度反馈消息。动作适合作为时间不确定，目标导向型的操作接口。