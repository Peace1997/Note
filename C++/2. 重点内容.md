
## 一、编译内存

### 1.  C++程序编译过程

![300](C++1.png)

**编译预处理：** 处理以 # 为开头的指令
**编译、优化：**  将源码 . cpp 文件翻译为. s 汇编代码
**汇编：** 将汇编代码. s 翻译成机器指令. o 文件
**链接：** 把引用的其他目标文件连接成一个整体，从而将. o 文件生成可执行的程序. exe 文件

### 2. C++ 内存管理

**栈：** 存放局部变量、函数参数、地址等信息，由编译器自动分配和释放
**堆：** 动态存储的内存空间（malloc），由程序员主动分配和释放，若程序执行结束还未释放，系统会自动回收。
**全局区/静态存储区**：存放全局变量和静态变量，程序运行结束后，由系统自动分配和释放。
**常量区：** 存放常量，不允许修改，程序运行结束后，由于系统自动分配和释放。
**代码区：** 存放代码，不允许修改，但可以执行，编译后的二进制文件存储在这里。

### 3. 栈和堆的区别

**栈：** 由于系统分配，在内存中通常是一片连续的空间，申请效率高，程序员无法控制，栈中存放的内容有限制（通常是局部变量和函数参数）
**堆：** 由程序员分配，在内存中通常不是一片连续的空间，申请方便，但是容易产生碎片， 堆中可以存放的内容无限制

### 4. 变量的区别

全局变量、静态全局变量、局部变量、静态局部变量区别

*按作用域划分：*

- **全局变量：** 具有全局作用域，在一个源文件定义，其他源文件可通过`extern`调用
- **静态全局变量：** 具有文件作用域，只能在定义它的源文件调用，其他源文件可定义同名的静态全局变量。
- **局部变量：** 具有局部作用域，仅在相应函数运行期间调用，函数运行结束后，变量撤销，所占内存收回。
- **静态局部变量：** 具有局部作用域，同全局变量和静态全局变量一样仅需一次初始化，从初始化后到程序结束一直在运行，仅对自己定义的函数体始终可见。

*按分配内存：*

- 栈：局部变量
- 静态存储区区：全局变量、静态全局变量、静态局部变量


### 5. 内存对齐

内存空间都是按 byte 划分的，理论上对于任何类型数据可以从任意地址开始分配，但是实际上计算机系统对基本类型数据在内存中存放是有限制的，它要求数据在内存中存放的首地址是某值(4、8)的倍数。

> int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。

*内存对齐的作用：*
- 便于移植：有些硬件设置只支持在特定地址读取特定类型数据， 
- 提高性能：提高内存访问效率，CPU 读取内存时是一块一块的读取，未对齐内存可能需要做两次内存访问，而对齐内存一次访问即可。

*对齐规则：*
- 基本数据类型的对齐值就是其 sizeof 值;
- 结构体的对齐值是其成员的最大对齐值;
- 编译器可以设置一个最大对齐值，实际对齐值是该类型的对齐值与默认对齐值取最小值得来

### 6. 内存泄漏

由于疏忽或错误导致的程序未能释放已经不再使用的内存。

*产生的原因？*
- malloc、new 用完后没有 free、delete
- 指针重新赋值，导致其中一个指针初始时指向的那块内存空间无法找到。
- 堆内存泄漏，因为堆是用户控制动态分配的，如果使用不当，会产生内存泄漏。

*如何解决？*
- **内部封装**：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。
- **智能指针**：智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用。


### 7. 面向对象三大特性

对象是指具体的某一个事物，这些事物的抽象就是类，类中包含方法和变量

**封装**：将具体的实现过程和数据封装成一个函数，只能通过接口访问，降低耦合性

**继承**：子类继承父类的特征和行为，子类可以对父类非private的方法进行重写，增强了类之间的耦合性，但是当父类的成员变量、成员函数或者类本身被final关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。

**多态**：不同的继承类的对象，对同一消息做出不同的响应（同一行为具有多个不同表现形式）。基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现形式。

重载：多个同名函数的不同表先形式

### 8. C++11 新特性

智能指针




### 多线程和多进程

线程是一个轻量级的子进程，是最小的处理单元，一个进程由多个线程组成；

线程之间共享进程的数据，共享容易，同步难
进程之间相互独立，同步容易，共享难，共享需要 IPC。

进程间通信（IPC）的方式：
- 消息队列：在内核中创建一个队列，队列中每个元素就是一个数据报，不同进程可以通过这个句柄去访问这个队列；消息队列独立于发送与接受进程，可以通过顺序和消息类型读取，也可通过 FIFO 读取；消息队列可以实现双向通信。
- 共享内存：将同一块物理内存映射到不同的进程的虚拟地址空间中，实现不同进程对同一资源的共享。不需要从用户态的频繁切换和拷贝数据，直接从内存读取就可，共享内存是临界资源，操作时必须保证原子性，使用信号量和互斥锁都可以



### 全局变量为什么不能定义在头文件

全局变量仅需一次初始化（定义一次），若该头文件被其他多个文件 include 时，那么该全局变量就会被重复定义。





迭代器？？？？