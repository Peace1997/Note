
## 一、编译内存

### 1.  C++程序编译过程

![300](C++1.png)

**编译预处理：** 处理以 # 为开头的指令
**编译、优化：**  将源码 . cpp 文件翻译为. s 汇编代码
**汇编：** 将汇编代码. s 翻译成机器指令. o 文件
**链接：** 把引用的其他目标文件连接成一个整体，从而将. o 文件生成可执行的程序. exe 文件

### 2. C++ 内存管理

**栈：** 存放局部变量、函数参数、地址等信息，由编译器自动分配和释放
**堆：** 动态存储的内存空间（malloc），由程序员主动分配和释放，若程序执行结束还未释放，系统会自动回收。
**全局区/静态存储区**：存放全局变量和静态变量，程序运行结束后，由系统自动分配和释放。
**常量区：** 存放常量，不允许修改，程序运行结束后，由于系统自动分配和释放。
**代码区：** 存放代码，不允许修改，但可以执行，编译后的二进制文件存储在这里。

### 3. 栈和堆的区别

**栈：** 由于系统分配，在内存中通常是一片连续的空间，申请效率高，程序员无法控制，栈中存放的内容有限制（通常是局部变量和函数参数）
**堆：** 由程序员分配，在内存中通常不是一片连续的空间，申请方便，但是容易产生碎片， 堆中可以存放的内容无限制

### 4. 变量的区别

全局变量、静态全局变量、局部变量、静态局部变量区别

*按作用域划分：*

- **全局变量：** 具有全局作用域，在一个源文件定义，其他源文件可通过`extern`调用
- **静态全局变量：** 具有文件作用域，只能在定义它的源文件调用，其他源文件可定义同名的静态全局变量。
- **局部变量：** 具有局部作用域，仅在相应函数运行期间调用，函数运行结束后，变量撤销，所占内存收回。
- **静态局部变量：** 具有局部作用域，同全局变量和静态全局变量一样仅需一次初始化，从初始化后到程序结束一直在运行，仅对自己定义的函数体始终可见。

*按分配内存：*

- 栈：局部变量
- 静态存储区区：全局变量、静态全局变量、静态局部变量


### 5. 内存对齐

内存空间都是按 byte 划分的，理论上对于任何类型数据可以从任意地址开始分配，但是实际上计算机系统对基本类型数据在内存中存放是有限制的，它要求数据在内存中存放的首地址是某值(4、8)的倍数。

> int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。

*内存对齐的作用：*
- 便于移植：有些硬件设置只支持在特定地址读取特定类型数据， 
- 提高性能：提高内存访问效率，CPU 读取内存时是一块一块的读取，未对齐内存可能需要做两次内存访问，而对齐内存一次访问即可。

*对齐规则：*
- 基本数据类型的对齐值就是其 sizeof 值;
- 结构体的对齐值是其成员的最大对齐值;
- 编译器可以设置一个最大对齐值，实际对齐值是该类型的对齐值与默认对齐值取最小值得来

### 6. 内存泄漏

由于疏忽或错误导致的程序未能释放已经不再使用的内存。

*产生的原因？*
- malloc、new 用完后没有 free、delete
- 指针重新赋值，导致其中一个指针初始时指向的那块内存空间无法找到。
- 堆内存泄漏，因为堆是用户控制动态分配的，如果使用不当，会产生内存泄漏。

*如何解决？*
- **内部封装**：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。
- **智能指针**：智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用。


### 7. 面向对象三大特性

对象是指具体的某一个事物，这些事物的抽象就是类，类中包含方法和变量

**封装**：将具体的实现过程和数据封装成一个函数，只能通过接口访问，降低耦合性

**继承**：子类继承父类的特征和行为，子类可以对父类非private的方法进行重写，增强了类之间的耦合性，但是当父类的成员变量、成员函数或者类本身被final关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。

**多态**：不同的继承类的对象，对同一消息做出不同的响应（同一行为具有多个不同表现形式）。基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现形式。

重载：多个同名函数的不同表先形式

### 8. C++11 新特性


 **auto & decltype** ：C++11 引入了 auto 和 decltype 关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。

**智能指针**：很多人谈到 c++，说它特别难，可能有一部分就是因为 c++的内存管理吧，不像 java 那样有虚拟机动态的管理内存，在程序运行过程中可能就会出现内存泄漏，然而这种问题其实都可以通过 c++11 引入的智能指针来解决。
	- 共享指针：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。
	- 独占指针：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。
	- 弱指针：指向 shared_ptr 指向的对象，能够解决由shared_ptr带来的循环引用问题
>https://blog.csdn.net/luanfenlian0992/article/details/118771472

**基于范围的for循环**


### 9. 多线程和多进程

线程是一个轻量级的子进程，是最小的处理单元，一个进程由多个线程组成；

线程之间共享进程的数据，共享容易，同步难
进程之间相互独立，同步容易，共享难，共享需要 IPC。

进程间通信（IPC）的方式：
- 消息队列：在内核中创建一个队列，队列中每个元素就是一个数据报，不同进程可以通过这个句柄去访问这个队列；消息队列独立于发送与接受进程，可以通过顺序和消息类型读取，也可通过 FIFO 读取；消息队列可以实现双向通信。
- 共享内存：将同一块物理内存映射到不同的进程的虚拟地址空间中，实现不同进程对同一资源的共享。不需要从用户态的频繁切换和拷贝数据，直接从内存读取就可，共享内存是临界资源，操作时必须保证原子性，使用信号量和互斥锁都可以



### 10 . 全局变量为什么不能定义在头文件

全局变量仅需一次初始化（定义一次），若该头文件被其他多个文件 include 时，那么该全局变量就会被重复定义。





# 二、 语言特性

## STL
 standard template library，其包含有大量的模板类和模板函数，是一些容器、算法和其他一些组件的集合，是一些容器、算法和其他一些组件的集合，STL 基本上达到了各种存储方法和相关算法的高度优化。

## Python 与 C++语言特性

Python 是脚本语言，脚本语言不需要编译，直接解释执行，由解释器进行解释。程序代码脚本语言可以直接执行，因此只需要编写-执行即可。 Python更加灵活
C++ 是编译型语言，需要编译成二进制代码，以可执行文件执行，需要经过编写-编译-汇编-链接-执行。C++ 逻辑更加清晰

*为什么要用 Python 而不用 C++*

- 首先ROS本身对Python有非常好的支持
- 主要从事强化学习的研究，通过 Pytorch 进行训练，使用 Python 语言更加统一，方便数据转换，直接获取机器人状态、激光雷达信息后，直接转成 Tensor 类型，传给神经网络进行训练
- Pytorch搭建神经网络简单，而且反向传播梯度计算， 优化器梯度下降更新参数，都已经封装好了，包括各种激活函数等，训练方便快捷，而且还有可视化软件tensorboard、wandb可以方便的进行可视化展示，矢量化环境进行并行训练。
- Python 修改代码后不需要重新编译，编写执行即可，可以更关注高层的设计


- 不需要重新编译；C++需要借助 catkin 和 ROS 的编译系统，每次对程序代码进行改动，都需要使用 catkin_make 进行重新编译。
- 在C++中很多情况下需要显示的指定，例如C++需要现实的创建一个节点句柄用来创建话题、服务和动作，而Python则不需要显示创建节点句柄，因为ROS的Python接口可以隐式的实现。

*为什么要用 C++ 不用 Python？*

- 如果用户想在每秒帧数高、延迟低的要求下在纯粹的C++游戏引擎中进行强化学习研究，对于这种环境而言，使用纯粹的C ++库比Python库要适合得多。
- 由于全局解释器锁（GIL），Python 一次无法运行多个系统线程。多重处理是一种替代方法，但扩展性欠佳，并存在诸多缺点。C++没有这样的约束或限制，而且它的线种易于使用和创建。
- C++执行速度快、可移植性强、与硬件和其他软件系统的接口简单


*C++如何调用 Pytorch 训练好的模型*

用 Pytroch 进行训练，C++执行测试。
Pytorch搭建神经网络简单，而且反向传播梯度计算， 优化器梯度下降更新参数，都已经封装好了，包括各种激活函数等，训练方便快捷，而且还有可视化软件tensorboard、wandb可以方便的进行可视化展示，矢量化环境进行并行训练。
将训练好的模型保存为pt文件，可以通过调用 trace 函数，可以将 pt 文件转换成序列化文件，供C++调用，tensorflow可以直接保存为pd二进制文件。
通过C++搭建一个前向神经网络，此时已经不需要进行反向传播，而且一般全连接层可以满足大部分的需求，0.几毫秒即可完成一次前向传播计算。

*C++和 C 语言？*

C语言是面向过程的编程，C++是面向对象（类和继承）的编程，而且能够更方便的定义数据结构的属性，用到这些数据结构时，把他们当作“黑匣子”使用。


*什么是抽象？*
有选择地忽略；编程就是通过建立抽象来忽略我们此刻并不重视的因素。

# 二、 C++  & ROS


C++工程代码通常分为两个部分：
- 用于实现具体算法
- 用于进行 ROS 接口封装（数据的输入输出、以及算法的调用）

## ROS 介绍

ROS 是一个适用于机器人的、开源的元操作系统/中间件。
> 元操作系统建立在操作系统之上，允许不同的进程（节点）在运行时相互通信

ROS 提供了操作系统应有的服务，包括硬件抽象、底层设备控制、常用函数实现、进程间消息传递。
ROS实现了几种不同的通信方式，同步通信的服务机制、异步通信的。



##  C++编译过程
*g++编译过程:*

- 预处理：`test.cpp`  $\rightarrow$ `test.i`
- 编译： `test.i` $\rightarrow$ `test.s`
- 汇编：`test.s` $\rightarrow$ `test.o`
- 连接：`test.o` + `libxx.o` $\rightarrow$ `test`

当程序涉及多个 C++文件和外部依赖时，逐一输入 g++命令将很不方便，所以通常使用 **makefile**文件来编写编译脚本，使用 **make** 命令来进行编译，编译完成后可以调用 make clean 命令清除这些中间文件。

当程序有众多依赖和关联的时候，如果全部手动维护依赖关系是很麻烦的，**Cmake** 可以自动处理程序之间的关系，并产生相应的 makefile 文件，然后调用 make 就能轻松编译了。

> 使用CMake，需要新建一个MakeLists.txt文件，编写它需要遵循Cmkae语言。


*ROS 处理流程：*
系统按话题传递消息数据，系统通过回调函数处理话题消息。

> 回调函数：把函数以参数的形式传给其他函数，由其他函数调用，那就是回调函数；
> 回调函数最经典的场景就是异步通信，当前函数所要执行的条件还不满足，需要等待其他动作完成后再执行，因此就将这个函数的执行委托给其他函数，等它执行完后，在调用该回调函数。


## 使用 catkin 编译 C++

**package. xml**
用于声明项目的各类依赖

**CMakeLists. txt**
ROS 编译系统需要 CMakeLists. txt 来告诉系统编译哪些文件，改文件存在于 src 文件下所在的各个目录（package. xml 文件所在的目录），注意与 catkin 工作区根目录下的 CMakeLists. txt 搞混。

**catkin_make**

编译 ROS 节点程序需要在 catkin 工作区(catkin_workspace)根目录下调用 catkin_make，这一操作会编译所有的节点并保证所有依赖是最新的。

```c
catkin_workspace/
	src/
		CMakeLists.txt
		package_1/
			CmakeLists.txt
			package.xml
		package_2/
			CmakeLists.txt
			package.xml
	build/
	devel/
```

## 话题、服务、动作

话题、服务、动作是ROS节点通信的三种通信方式。

**话题**：是一种发布/订阅通信机制。话题发布者向多个订阅者进行广播，但通信是单向的。
**服务**：是同步的跨进程函数调用；服务器端定义一个回调函数来处理服务请求，并声明这个服务，客户端向服务器发送请求并获得响应，但缺乏关于进度的信息。服务适合哪些只需要偶尔去做，并且会在有限时间按内完成的任务。

>Topic 发布一个消息后，就直接去执行后面的程序；而Service 调用一个服务，会一直等待结果

**动作**：是异步的，与服务类似，动作客户端向动作服务器发送请求以实现某些目标并获得结果。与服务不同，在执行动作时，动作服务器会向动作客户端发送进度反馈消息。动作适合作为时间不确定，目标导向型的操作接口。

单纯topic 和 server 无法很好实现连续反馈。ROS Service会阻塞程序流，程序无法进行其它的工作，有时我们需要同时进行多个任务。ROS Action可以满足要求，ROS Action提供程序的**非阻塞执行**。action采用了服务器端/客户端（client and server）的工作模式。client和server之间通过**actionlib**定义的“action protocol”进行通讯。这种通讯协议是基于ROS的消息机制实现的，为用户提供了client和server的接口，接口如下图所示：

>move_base收到goal目标后，将目标goal通过基于actionlib的client向服务器发送，服务器根据TF关系以及发布的odom消息不断反馈（feedbackcall）机器人的状态到客户端，让move_base做路径规划，控制Twist()。