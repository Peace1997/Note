

栈和队列是限定插入和删除只能在表的“端点”进行的**线性表**，即插入和删除位置受限的线性表

为什么需要堆栈：由于顺序表在中间插入和删除时，需要进行大量移动。

栈：
后进先出

队列
先进先出

## 栈

仅在**表尾**进行插入、删除操作的

同线性表相同，仍为一对一关系
用顺序栈或链栈存储均可，但以顺序栈更为常见
只能在栈顶运算，且访问结点时按照后进先出的原则

==**先进后出**==

案例：
- 进制转换
- 括号匹配的检验
- 表达式求值

### 基本操作
- 初始化
- 销毁栈
- 判空
- 求栈的长度
- 取栈顶元素
- 置空
- **入栈**操作
- **出栈**操作


### 顺序栈：

附设 top 指针（栈顶；通常指向栈顶元素之上的下标地址-> 方便直接插入值）和 base 指针（栈底；0）、stack_size：栈可使用的最大容量
空栈：top == base 
栈满：top-base == stacksize ； 上溢出；
上溢：栈已满，又要压入元素；通常认为是一种错误
下溢：栈已空，还要弹出元素；通常认为是一种结束条件

#### 数据结构

```c
#define MAXSIZE 100
typedef struct{
	SElemType *base; //栈底指针
	SElemtype *top; // 栈顶元素
	int stacksize; //栈可用最大容量
}SqStack;

//入栈
Status Push(SqStack &S,SElemType e){
	if(S.top -S.base == S.stacksize) //栈满
		return ERROR;
	*S.top = e;
	S.top++; // *S.top++=e;
	return OK;
}
//出栈
Status Pop(SqStack &S, SElemType &e){
	if(S.top == S.base) //栈空
		return ERROR;
	--S.top;
	e = *S.top;
	return OK;
}

```

###  链栈
链栈的头指针就是栈顶
不需要头结点（此时插入不需要向顺序栈一样额外增加一个地址）
基本不存在栈满的情况
空栈相当于头指针指向空
插入和删除仅在栈顶执行
```python

typedef struct StackNode{
	SElemType data;
	struct StackNode *next;
}StackNode,*LinkStack

//入栈
Status Push(LinkStack &S,SElemType e){
	p = new StackNode;
	p->data = e;
	p->next = S;
	S = p;
	return OK;
}

//出栈
Status Pop(LinkStack &S,SElemType &e){
	if (S==NULL) return ERROR;
	e = S->data;
	p =S;
	S =S->next;
	delete p;
	return OK;
}
```

### 栈与递归

递归问题—— 分治法解决
**条件**：
- 能够将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同
- 可以通过上述转化而使问题简化
- 必须要有一个明确的递归出口，或称递归的**边界**。
```c
void p(参数表){
	if (递归结束条件) 可直接求解归纳； —————— 基本项
	else p(较小的参数)； ———————— 归纳项
}
```


==**后调用先返回，递归需要用到栈**==

**递归工作栈** —— 递归程序运行期间使用的数据存储区
栈用于“工作记录”  -----> 实参，局部变量，返回地址

每次调用都需要生成工作记录，保存状态信息，入栈； 返回时要出栈，恢复状态信息。时间开销大。 


## 队列

在表尾（队尾）进行插入，在表头（队头）进行删除

==**先进先出**==
顺序队或链队，以循环顺序队列更常见。

基本操作同栈


### 顺序队

#### 数据结构
```c
# def MAXQSIZE 100 
typedef struct{
	QElemType *base; //初始化的动态分配存储空间
	int front; // 头指针
	int rear; //尾指针
}SqQueue;
```





#### 循环顺序队

解决假溢出：rear =MAXQSIZE，front!=0

利用模（取余）； %MAXQSIZE

需要判断是否队空、队满
- 设一个标志
- 另设一个变量，记录元素个数
- **少用一个元素空间**，少用一个空间

少用一个元素空间：
- 队空：front == rear
- 队满：(rear+1)%MAXQSIZE == front
- 队列长度：(Q.rear - Q.front + MAXQSIZE) %  MAXQSIZE

```c
# def MAXQSIZE 100 
typedef struct{
	QElemType *base; //初始化的动态分配存储空间
	int front; // 头指针
	int rear; //尾指针
}SqQueue;

//入队
Status EnQueue (SqQueue &Q, QElemType e){
	if ((Q. rear+1)%MAXQSIZE == Q. front) return ERROR;
	Q.base[Q.rear] = e;
	Q.rear[Q.rear+1]%MAXQSIZE;
}
//出队
Status DeQueue (SqQueue &Q, QElemType &e){
	if (Q.rear == Q.front) return ERROR;
	e = Q.base[Q.front];
	Q.front = (Q.front+1)%MAXQSIZE;
	return OK;
}


```

### 链队

有队头结点（更方便判断是否有）

```c
# def MAXQSIZE 100 
typedef struct Qnode{
	QElemType data;
	struct Qnode *next;
}QNode,*QueuePtr;


//入队
Status EnQueue(LinkQueue &Q,QElemType e){
	p = (QueuePtr) malloc(sizeof(Qnode));
	if(!p) exit(OVERFLOW);
	p-data = e;
	p-next = NULL:
	Q.rear->next =p;
	Q.rear =p;
	return OK;
}

//出队
Status DeQueue(LinkQueue &Q,QElemType e){
	if(Q.front==Q.rear) return ERROR //判空
	p = Q.front->next;
	e = p->next;
	Q.front->next = p->next;
	if (Q.rear == p) Q.rear=Q.front //此时p为尾结点
	delete p
	
	return OK;
}
```






案例：
- 舞伴问题