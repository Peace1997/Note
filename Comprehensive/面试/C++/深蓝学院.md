# 深蓝学院--C++基础与深度理解

*什么是C++*
C语言的扩展
- 关注性能
	- 与底层硬件紧密结合
	- 对象生命周期的精确控制
- 引入大量特征，便于工程实践
	- 三种编程范式：面向过程、面向对象、泛型
	- Zero-Overhead Abstraction
		- 不需要为没有使用的语言特性付出成本
			- 虚函数
		- 使用了一些语言特性不等于付出运行期成本（在编译器被优化掉）

C++是一系列不断衍进的标准集合
- 语言本身的改进
- 标准库的改进

*C++工具:*
- cpp reference（查阅）
- Compiler（可查看汇编代码，运行代码）
- insight(对语法进行展开)

*C++的编译/链接模型*
编译、链接
- 编译耗资源但一次处理输入较少
- 链接输入较多但处理速度较快
![[Pasted image 20240115175521.png]]

定义 & 声明
翻译单元：头文件 + 源文件（声明）
一处定义原则

*g++编译过程:*

- 预处理：`test.cpp`  $\rightarrow$ `test.i`：
	- 源文件转为翻译单元，防止头文件被循环展开（通过#ifdef、#pragma once解决）
- 编译： `test.i` $\rightarrow$ `test.s`
	- 将翻译单元转换为相应的汇编语言表示
	- 编译优化（加快编译，但是不利于调试）
	- 增量编译 & 全部编译
- 汇编：`test.s` $\rightarrow$ `test.o`
- 链接：`test.o` + `libxx.o` $\rightarrow$ `test`
	- 合并多个目标文件，关联声明与定义
	- 常出现找不到定义的错误


指定类型，方便在内存中分配空间

语句加大括号{}形成语句体

*系统IO*

头文件 < >和 " " 的引用
- " "：从本地开始索引
- < > ：从系统标准库找

头文件 `include <iostream>`
名字空间 `namespace`
`std`名字空间：标准系统名字空间

cout/cerr/clog：输出
- 输出目标
- 是否立即刷新缓冲区
- 缓冲区刷新（flush、endl）
- printf （`#include<cstdio>`） 
- C++20 格式化库：新的解决方案
cin：输入

*结构体*
函数可以引入到结构体

*初始化*
在内存（栈/堆）中开辟空间，
*类型*
类型是编译期概念，可执行文件中不存在类型概念
C++是一个强类型语言
引入类型是为了更好地描述程序，防止误用。

类型描述了：
- 存储所需要的尺寸（`sizeof`，所占内存大小）
- 取值空间
- 对齐信息

不同硬件环境会有不同：

| 类型 | 大小（byte） | 描述 |
| :--- | :--: | :--- |
| `int` | 4 | 有符号整型 |
| `short` | 2 |  |
| `long` | 8 |  |
| `long long` | 8 |  |
| `unsigned int` | 4 | 无符号整型，unsigned表示无符号 ；signed表示有符号 |
|  |  |  |
| `char` | 1 | 字符；单引号 |
| `char_16t` | 2 | C++11引入 |
| `char_32t` | 4 | C++11引入 |
|  |  |  |
| `float` | 4 | 浮点数 |
| `double` | 8 |  |
| `long double` | 16 |  |
|  |  |  |
|  |  |  |
|  |  |  |

`extend` + 数值类型：声明

*初始化*
- 缺省初始化
- 直接/拷贝初始化

##   指针
![[Pasted image 20240117112239.png]]

特点：
- 可以指向不同对象
- 指针尺寸相同

- & 取地址操作符
- *  解引用操作符
C++11
`int *p = nullptr`
>nullptr（类型为nullptr_t）：空指针

`void *`：可以保存任意地址

指针vs 对象
- 复制成本低，读写成本高

指针的非法使用：
- 为空
- 地址信息非法
- 解决方法：引用



##  引用
- 引用就是对象的别名
- 引用后就和被引用的对象绑定了。
- 构造时需要绑定对象，不存在空引用
- 指针可以修改地址也可修改指针指向的内容，而引用智能修改绑定的内容
- 尽可能保护程序，尽可能避免出现指针非法

引用的非法使用：
- 指向已经销毁的地址

引用汇编实现就是指针
指针也是对象，可以定义引用
```c++
int * ptr = nullptr
int* &ref = ptr //ref是个引用，它绑定在ptr指针上
```

**存在指针的指针，但不存在引用的引用**

## 常量

`const` + 数值类型：只能读不能写
防止非法操作、优化程序逻辑

常量指针
`int * const ptr`：指针地址不修改
`const int * ptr`：指针指向的内容不修改，地址可修改

const在* 前面指针指向的内容不变，const用于修饰int； const在 * 后面地址不发生改变，指针为常量。

常量指针可指向变量

常量引用主要用于传递形参：快速拷贝，同时防止被修

常量表达式：`constexpr`，声明的是编译期常量
常量表达式constexpr通常位于* 的左侧表示指针是常量表达式


## 类型别名与类型的自动推导

类型别名作用：引入特殊含义便于使用
`tyepdef + 数值类型 ` 
`using xx= 数值类型`

类型别名 & 指针 & 引用
- 应将指针类型别名是为一个整体，指针地址不能变，即指针为常量
- 不能通过类型别名构造引用的引用



类型的自动推导
`auto` + 初始化表达式，可能会产生类型退化 