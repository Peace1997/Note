

Robust Recovery Controller for a Quadrupedal Robot using Deep Reinforcement Learning
Joonho Lee, Jemin Hwangbo, and Marco Hutter
Robotic Systems Lab, ETH Zurich
真实
摔倒 100 次恢复，成功率 97%


Learning to Walk in Minutes Using Massively Parallel Deep Reinforcement Learning
ETH Zurich and NVIDIA
![[Pasted image 20220914142851.png]]

RMA: Rapid Motor Adaptation for Legged Robots
UC Berkeley
![[Pasted image 20220914143350.png]]


![[Pasted image 20220914143522.png]]

![[Pasted image 20220914143545.png]]

![[Pasted image 20220914143558.png]]


![[Pasted image 20220914143637.png]]

之前所说的失败率是针对所有速度指令、所有复杂环境下综合的失败率，不过很多论文在复杂环境下失败率的计算是在某一速度下针对单个复杂环境计算的。

测试的成功率是针对不同情况下进行的， 比如说针对楼梯不同的高度、宽度下进行测试或斜坡的不同坡度进行测试，一般都是随着环境难度增加，准确率都会有所下降：例如
![[Pasted image 20220914142851.png]]
### 如何将训练好的模型导入真实机器狗中

**任务需求**：在实体机器人中导入在仿真环境中训练好的模型，通过不断采集机器人当前的状态信息，完成对机器人的控制，
**提供**：
已经训练好的机器人模型（.pt文件）
**需求**：
在四足机器人中搭建一个 ROS 系统
**问题描述**：
首先，对于已有训练好的机器人模型，它需要获取输入数据，模型根据输入数据，输出相应的动作（关节目标位置），依据模型的状态（输入）空间，对于输入数据我们需要获取基体的信息以及关节信息，对于输出的动作，我们需要转换成控制机器人执行的命令。

**整体方案**

**输入数据的获取**：

我们需要获取的输入数据主要包括：基体的线速度（x、y、z）、角速度（x、y、z）、关节位置差值、关节速度、上一时刻的动作、重力向量、基体的指令速度。其中对于重力向量、基体的指令速度可以预先进行设定，上一时刻的动作也可以在运行过程中进行记录。因此输入数据的重点就是获取基体、关节的信息。
对于基体的角速度，可以通过 IMU 传感器进行获取，通过在 ROS 中订阅 IMU 的节点，就可以完成获取基体的角速度信息（`angular_velocity`），也可以通过moveit的相关函数来获取、以及订阅 `/base_feedback` 相关话题进行
> 对于 IMU 通过可以得到当前的方向、角速度、线加速度信息
> http://docs.ros.org/en/lunar/api/sensor_msgs/html/msg/Imu.html
> moveit：
> http://docs.ros.org/en/groovy/api/moveit_ros_planning_interface/html/group__query__robot__state.html

对于基体的线速度：`odom` 这个话题来获取当前基体的线速度的信息，
> 日后对于集体的位置和方向也可以通过odom来获取

对于基体的角速度，可以通过 IMU 传感器进行获取，通过在 ROS 中订阅 IMU 的节点，就可以完成获取基体的角速度信息（`angular_velocity`）。对于关节位置和关节速度：可以通过moveit应用来获取（ move_group 监听 /joint_states话题来获取当前关节的状态信息）。对于基体的线速度：`odom` 这个话题来获取当前基体的线速度、角速度的信息，但是通过距离除以时间得到的，没有IMU测量的角速度精确。

**输出数据的转换**：

对于模型的输出通常是目标关节的角度、速度、力矩，我们可以通过moveit应用来完成关节的控制（使用 moveit_commander 包提供的 API)。

moveit是基于ROS的应用，以 move_group 为核心节点，集成了各种组件，用于提供各种 ROS 动作和服务，供用户使用。由于moveit无法与实体机器人直接交互，需要ros_control作为用户提供的应用与机器人之间的中间件,可以获取关节的状态信息，然后完成关节的控制任务，ros_control 在ROS1和ROS2中都有提供。
![[sim2real.png]]
![[ROS_Control.png]]

### 控制频率

完成一次动作执行所消耗的时间主要包括 4 个部分：神经网络策略计算、控制器力矩计算、执行器、仿真。
在训练时，设置的仿真步长为0.005 （200hz），策略控制频率是 0.02 (50hz)。由于GPU限制，同时并行训练的限制，控制器、执行期、仿真的运算、网络更新等仿真都需要消耗时间,设置的50hz，基本就是综合整个计算资源设置的。
![](time.png)




平坦环境下：

**无指令切换时：**
x 轴线速度：0.2～2 m/s； - 0.4～ - 2.2 m/s
y 轴线速度：0.25～1.5 m/s；-0.85 ～ -1.8 m/s
z 轴角速度：0.5 ~ 3.14  m/s ; - 0.5～ - 3.14 m/s
 
当前的步态，前后腿活动范围有差异，当速度比较低时，后腿活动范围较大，前腿活动范围较小，很容易发生磕碰。

**解决**：
- 我当前训练时是对 \[-1, 1]的速度进行训练的，
- 加入一些专家数据，通过模范学习


0.25 ～ -0.85 失败次数：45

**有指令切换时：**
x 轴线速度：0.2～1.5 m/s ；


**复杂环境下：**

成功率 100：

**上下斜坡 + 粗糙地形**：
0～37 度 

如果不加粗糙地形大概43度。

**上楼梯**
楼梯高度：0.21 m
楼梯宽度：0.3 m

**下楼梯**
楼梯高度：0.18 m
楼梯宽度：0.32 m

**障碍物**









